###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                24/Oct/2016  15:11:58
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Components\osal\common\OSAL.c
#    Command line       =  
#        -f "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=50 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440 "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack
#        Mesh 1.0.0\Components\osal\common\OSAL.c" -D LOG_OUT -D
#        UART1_PROTOCOL_RESOLVER=1 -D xISQC -D NWK_AUTO_POLL -D ZTOOL_P1 -D
#        ISR_KEYINTERRUPT -D xMT_TASK -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        xLCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC
#        "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\WaterMachine\List"
#        -lA "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\WaterMachine\List"
#        --diag_suppress Pe001,Pa010 -o
#        "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\WaterMachine\Obj"
#        -e --no_code_motion --debug --core=plain --dptr=16,1
#        --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 8 -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack
#        Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\Source\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\Frame\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\Module\WaterMachine\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz
#    List file          =  
#        E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\WaterMachine\List\OSAL.lst
#    Object file        =  
#        E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\Demo_App_V1.7饮水机控制增加uart\CC2530DB\WaterMachine\Obj\OSAL.r51
#
###############################################################################

E:\资源(G：)\#个人项目\ZigbeeProject\Z-Stack Mesh 1.0.0\Components\osal\common\OSAL.c
      1          #include <string.h>
      2          
      3          #include "comdef.h"
      4          #include "hal_board.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
      5          #include "OSAL.h"
      6          #include "OSAL_Tasks.h"
      7          #include "OSAL_Memory.h"
      8          #include "OSAL_PwrMgr.h"
      9          #include "OSAL_Clock.h"
     10          
     11          #include "OnBoard.h"
     12          
     13          /* HAL */
     14          #include "hal_drivers.h"
     15          
     16          #ifdef IAR_ARMCM3_LM
     17            #include "FreeRTOSConfig.h"
     18            #include "osal_task.h"
     19          #endif
     20          
     21          /*********************************************************************
     22           * MACROS
     23           */
     24          
     25          /*********************************************************************
     26           * CONSTANTS
     27           */
     28          
     29          /*********************************************************************
     30           * TYPEDEFS
     31           */
     32          
     33          /*********************************************************************
     34           * GLOBAL VARIABLES
     35           */
     36          
     37          // Message Pool Definitions

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     38          osal_msg_q_t osal_qHead;
   \                     osal_qHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     39          
     40          /*********************************************************************
     41           * EXTERNAL VARIABLES
     42           */
     43          
     44          /*********************************************************************
     45           * EXTERNAL FUNCTIONS
     46           */
     47          
     48          /*********************************************************************
     49           * LOCAL VARIABLES
     50           */
     51          
     52          // Index of active task

   \                                 In  segment XDATA_I, align 1, keep-with-next
     53          static uint8 activeTaskID = TASK_NO_TASK;
   \                     activeTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for activeTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
     54          
     55          /*********************************************************************
     56           * LOCAL FUNCTION PROTOTYPES
     57           */
     58          
     59          static uint8 osal_msg_enqueue_push( uint8 destination_task, uint8 *msg_ptr, uint8 urgent );
     60          
     61          /*********************************************************************
     62           * HELPER FUNCTIONS
     63           */
     64          /* very ugly stub so Keil can compile */
     65          #ifdef __KEIL__
     66          char *  itoa ( int value, char * buffer, int radix )
     67          {
     68            return(buffer);
     69          }
     70          #endif
     71          
     72          /*********************************************************************
     73           * @fn      osal_strlen
     74           *
     75           * @brief
     76           *
     77           *   Calculates the length of a string.  The string must be null
     78           *   terminated.
     79           *
     80           * @param   char *pString - pointer to text string
     81           *
     82           * @return  int - number of characters
     83           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     84          int osal_strlen( char *pString )
   \                     osal_strlen:
     85          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     86            return (int)( strlen( pString ) );
   \   000004                ; Setup parameters for call to function strlen
   \   000004   12....       LCALL   `??strlen::?relay`   ; Banked call to: strlen
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
     87          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
     88          
     89          /*********************************************************************
     90           * @fn      osal_memcpy
     91           *
     92           * @brief
     93           *
     94           *   Generic memory copy.
     95           *
     96           *   Note: This function differs from the standard memcpy(), since
     97           *         it returns the pointer to the next destination uint8. The
     98           *         standard memcpy() returns the original destination address.
     99           *
    100           * @param   dst - destination address
    101           * @param   src - source address
    102           * @param   len - number of bytes to copy
    103           *
    104           * @return  pointer to end of destination buffer
    105           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    106          void *osal_memcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_memcpy:
    107          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    108            uint8 *pDst;
    109            const uint8 GENERIC *pSrc;
    110          
    111            pSrc = src;
   \   000009   7409         MOV     A,#0x9
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine9 & 0xFFFF
    112            pDst = dst;
   \                     ??CrossCallReturnLabel_2:
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   800C         SJMP    ??osal_memcpy_0
    113          
    114            while ( len-- )
    115              *pDst++ = *pSrc++;
   \                     ??osal_memcpy_1:
   \   000017   12....       LCALL   ?C_GPTR_LOAD
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   E9           MOV     A,R1
   \   00001C   2401         ADD     A,#0x1
   \   00001E   09           INC     R1
   \   00001F   E4           CLR     A
   \   000020   3A           ADDC    A,R2
   \   000021   FA           MOV     R2,A
   \   000022   A3           INC     DPTR
   \                     ??osal_memcpy_0:
   \   000023   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000026   70EF         JNZ     ??osal_memcpy_1
    116          
    117            return ( pDst );
   \   000028                REQUIRE ?Subroutine5
   \   000028                ; // Fall through to label ?Subroutine5
    118          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   02....       LJMP    ??Subroutine32_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   EC           MOV     A,R4
   \   000001   FE           MOV     R6,A
   \   000002   ED           MOV     A,R5
   \   000003   FF           MOV     R7,A
   \   000004   EE           MOV     A,R6
   \   000005   24FF         ADD     A,#-0x1
   \   000007   1C           DEC     R4
   \   000008   EF           MOV     A,R7
   \   000009   34FF         ADDC    A,#-0x1
   \   00000B   FD           MOV     R5,A
   \   00000C   EE           MOV     A,R6
   \   00000D   4F           ORL     A,R7
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FB           MOV     R3,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    119          
    120          /*********************************************************************
    121           * @fn      osal_revmemcpy
    122           *
    123           * @brief   Generic reverse memory copy.  Starts at the end of the
    124           *   source buffer, by taking the source address pointer and moving
    125           *   pointer ahead "len" bytes, then decrementing the pointer.
    126           *
    127           *   Note: This function differs from the standard memcpy(), since
    128           *         it returns the pointer to the next destination uint8. The
    129           *         standard memcpy() returns the original destination address.
    130           *
    131           * @param   dst - destination address
    132           * @param   src - source address
    133           * @param   len - number of bytes to copy
    134           *
    135           * @return  pointer to end of destination buffer
    136           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    137          void *osal_revmemcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_revmemcpy:
    138          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    139            uint8 *pDst;
    140            const uint8 GENERIC *pSrc;
    141          
    142            pSrc = src;
    143            pSrc += (len-1);
   \   000009   7409         MOV     A,#0x9
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000011   E9           MOV     A,R1
   \   000012   2C           ADD     A,R4
   \   000013   F9           MOV     R1,A
   \   000014   EA           MOV     A,R2
   \   000015   3D           ADDC    A,R5
   \   000016   FA           MOV     R2,A
   \   000017   E9           MOV     A,R1
   \   000018   24FF         ADD     A,#-0x1
   \   00001A   19           DEC     R1
   \   00001B   EA           MOV     A,R2
   \   00001C   34FF         ADDC    A,#-0x1
   \   00001E   FA           MOV     R2,A
    144            pDst = dst;
   \   00001F   8E82         MOV     DPL,R6
   \   000021   8F83         MOV     DPH,R7
   \   000023   800D         SJMP    ??osal_revmemcpy_0
    145          
    146            while ( len-- )
    147              *pDst++ = *pSrc--;
   \                     ??osal_revmemcpy_1:
   \   000025   12....       LCALL   ?C_GPTR_LOAD
   \   000028   F0           MOVX    @DPTR,A
   \   000029   E9           MOV     A,R1
   \   00002A   24FF         ADD     A,#-0x1
   \   00002C   19           DEC     R1
   \   00002D   EA           MOV     A,R2
   \   00002E   34FF         ADDC    A,#-0x1
   \   000030   FA           MOV     R2,A
   \   000031   A3           INC     DPTR
   \                     ??osal_revmemcpy_0:
   \   000032   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000035   70EE         JNZ     ??osal_revmemcpy_1
    148          
    149            return ( pDst );
   \   000037   80..         SJMP    ?Subroutine5
    150          }
    151          
    152          /*********************************************************************
    153           * @fn      osal_memdup
    154           *
    155           * @brief   Allocates a buffer [with osal_mem_alloc()] and copies
    156           *          the src buffer into the newly allocated space.
    157           *
    158           * @param   src - source address
    159           * @param   len - number of bytes to copy
    160           *
    161           * @return  pointer to the new allocated buffer, or NULL if
    162           *          allocation problem.
    163           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    164          void *osal_memdup( const void GENERIC *src, unsigned int len )
   \                     osal_memdup:
    165          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   8B..         MOV     ?V2,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
    166            uint8 *pDst;
    167          
    168            pDst = osal_mem_alloc( len );
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000016   8A..         MOV     ?V6,R2
   \   000018   8B..         MOV     ?V7,R3
    169            if ( pDst )
   \   00001A   EA           MOV     A,R2
   \   00001B   45..         ORL     A,?V7
   \   00001D   6011         JZ      ??osal_memdup_0
    170            {
    171              VOID osal_memcpy( pDst, src, len );
   \   00001F                ; Setup parameters for call to function osal_memcpy
   \   00001F   78..         MOV     R0,#?V0
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000024   EE           MOV     A,R6
   \   000025   FC           MOV     R4,A
   \   000026   EF           MOV     A,R7
   \   000027   FD           MOV     R5,A
   \   000028   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?DEALLOC_XSTACK8
    172            }
    173          
    174            return ( (void *)pDst );
   \                     ??osal_memdup_0:
   \   000030   AA..         MOV     R2,?V6
   \   000032   AB..         MOV     R3,?V7
   \   000034   02....       LJMP    ?Subroutine2 & 0xFFFF
    175          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    176          
    177          /*********************************************************************
    178           * @fn      osal_memcmp
    179           *
    180           * @brief
    181           *
    182           *   Generic memory compare.
    183           *
    184           * @param   src1 - source 1 addrexx
    185           * @param   src2 - source 2 address
    186           * @param   len - number of bytes to compare
    187           *
    188           * @return  TRUE - same, FALSE - different
    189           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    190          uint8 osal_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
   \                     osal_memcmp:
    191          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0,R4
   \   00000C   8D..         MOV     ?V1,R5
    192            const uint8 GENERIC *pSrc1;
    193            const uint8 GENERIC *pSrc2;
    194          
    195            pSrc1 = src1;
   \   00000E   89..         MOV     ?V4,R1
   \   000010   8A..         MOV     ?V5,R2
   \   000012   8B..         MOV     ?V6,R3
    196            pSrc2 = src2;
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FC           MOV     R4,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FD           MOV     R5,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FE           MOV     R6,A
    197          
    198            while ( len-- )
   \                     ??osal_memcmp_0:
   \   000021   A8..         MOV     R0,?V0
   \   000023   A9..         MOV     R1,?V1
   \   000025   E8           MOV     A,R0
   \   000026   24FF         ADD     A,#-0x1
   \   000028   F5..         MOV     ?V0,A
   \   00002A   E9           MOV     A,R1
   \   00002B   34FF         ADDC    A,#-0x1
   \   00002D   F5..         MOV     ?V1,A
   \   00002F   E8           MOV     A,R0
   \   000030   49           ORL     A,R1
   \   000031   6043         JZ      ??osal_memcmp_1
    199            {
    200              if( *pSrc1++ != *pSrc2++ )
   \   000033   A9..         MOV     R1,?V4
   \   000035   AA..         MOV     R2,?V5
   \   000037   AB..         MOV     R3,?V6
   \   000039   E9           MOV     A,R1
   \   00003A   2401         ADD     A,#0x1
   \   00003C   F5..         MOV     ?V4,A
   \   00003E   E4           CLR     A
   \   00003F   3A           ADDC    A,R2
   \   000040   F5..         MOV     ?V5,A
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   EC           MOV     A,R4
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   ED           MOV     A,R5
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   A3           INC     DPTR
   \   00004E   EE           MOV     A,R6
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000059   2401         ADD     A,#0x1
   \   00005B   0C           INC     R4
   \   00005C   E4           CLR     A
   \   00005D   3D           ADDC    A,R5
   \   00005E   FD           MOV     R5,A
   \   00005F   12....       LCALL   ?C_GPTR_LOAD
   \   000062   F8           MOV     R0,A
   \   000063   85..82       MOV     DPL,?XSP + 0
   \   000066   85..83       MOV     DPH,?XSP + 1
   \   000069   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00006C   12....       LCALL   ?C_GPTR_LOAD
   \   00006F   68           XRL     A,R0
   \   000070   60AF         JZ      ??osal_memcmp_0
    201                return FALSE;
   \   000072   7900         MOV     R1,#0x0
   \   000074   8002         SJMP    ??osal_memcmp_2
    202            }
    203            return TRUE;
   \                     ??osal_memcmp_1:
   \   000076   7901         MOV     R1,#0x1
   \                     ??osal_memcmp_2:
   \   000078   7403         MOV     A,#0x3
   \   00007A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007D   7F07         MOV     R7,#0x7
   \   00007F   02....       LJMP    ?BANKED_LEAVE_XDATA
    204          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   EC           MOV     A,R4
   \   000006   22           RET
    205          
    206          
    207          /*********************************************************************
    208           * @fn      osal_memset
    209           *
    210           * @brief
    211           *
    212           *   Set memory buffer to value.
    213           *
    214           * @param   dest - pointer to buffer
    215           * @param   value - what to set each uint8 of the message
    216           * @param   size - how big
    217           *
    218           * @return  pointer to destination buffer
    219           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    220          void *osal_memset( void *dest, uint8 value, int len )
   \                     osal_memset:
    221          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    222            return memset( dest, value, len );
   \   000007                ; Setup parameters for call to function memset
   \   000007   8C..         MOV     ?V0,R4
   \   000009   8D..         MOV     ?V1,R5
   \   00000B   78..         MOV     R0,#?V0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   EE           MOV     A,R6
   \   000011   FC           MOV     R4,A
   \   000012   7D00         MOV     R5,#0x0
   \   000014   12....       LCALL   `??memset::?relay`   ; Banked call to: memset
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001C   02....       LJMP    ?Subroutine3 & 0xFFFF
    223          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    224          
    225          /*********************************************************************
    226           * @fn      osal_build_uint16
    227           *
    228           * @brief
    229           *
    230           *   Build a uint16 out of 2 bytes (0 then 1).
    231           *
    232           * @param   swapped - 0 then 1
    233           *
    234           * @return  uint16
    235           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    236          uint16 osal_build_uint16( uint8 *swapped )
   \                     osal_build_uint16:
    237          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    238            return ( BUILD_UINT16( swapped[0], swapped[1] ) );
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FC           MOV     R4,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   C8           XCH     A,R0
   \   00000F   F9           MOV     R1,A
   \   000010   EC           MOV     A,R4
   \   000011   28           ADD     A,R0
   \   000012   FA           MOV     R2,A
   \   000013   E4           CLR     A
   \   000014   39           ADDC    A,R1
   \   000015   FB           MOV     R3,A
   \   000016   02....       LJMP    ?Subroutine0 & 0xFFFF
    239          }
    240          
    241          /*********************************************************************
    242           * @fn      osal_build_uint32
    243           *
    244           * @brief
    245           *
    246           *   Build a uint32 out of sequential bytes.
    247           *
    248           * @param   swapped - sequential bytes
    249           * @param   len - number of bytes in the uint8 array
    250           *
    251           * @return  uint32
    252           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    253          uint32 osal_build_uint32( uint8 *swapped, uint8 len )
   \                     osal_build_uint32:
    254          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    255            if ( len == 2 )
   \   000007   7402         MOV     A,#0x2
   \   000009   6E           XRL     A,R6
   \   00000A   700A         JNZ     ??osal_build_uint32_0
    256              return ( BUILD_UINT32( swapped[0], swapped[1], 0L, 0L ) );
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000013   02....       LJMP    ??osal_build_uint32_1 & 0xFFFF
    257            else if ( len == 3 )
   \                     ??osal_build_uint32_0:
   \   000016   7403         MOV     A,#0x3
   \   000018   6E           XRL     A,R6
   \   000019   703D         JNZ     ??osal_build_uint32_2
    258              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], 0L ) );
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000022   A3           INC     DPTR
   \   000023   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000026   7408         MOV     A,#0x8
   \   000028   78..         MOV     R0,#?V0
   \   00002A   12....       LCALL   ?L_SHL
   \   00002D   78..         MOV     R0,#?V4
   \   00002F   79..         MOV     R1,#?V0
   \   000031   12....       LCALL   ?L_ADD
   \   000034   8A82         MOV     DPL,R2
   \   000036   8B83         MOV     DPH,R3
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0,A
   \   00003D   E4           CLR     A
   \   00003E   F5..         MOV     ?V1,A
   \   000040   7410         MOV     A,#0x10
   \   000042   78..         MOV     R0,#?V0
   \   000044   12....       LCALL   ?L_SHL
   \   000047   78..         MOV     R0,#?V4
   \   000049   79..         MOV     R1,#?V0
   \   00004B   12....       LCALL   ?L_ADD
   \   00004E   AA..         MOV     R2,?V4
   \   000050   AB..         MOV     R3,?V5
   \   000052   AC..         MOV     R4,?V6
   \   000054   AD..         MOV     R5,?V7
   \   000056   805D         SJMP    ??osal_build_uint32_3
    259            else if ( len == 4 )
   \                     ??osal_build_uint32_2:
   \   000058   7404         MOV     A,#0x4
   \   00005A   6E           XRL     A,R6
   \   00005B   8A82         MOV     DPL,R2
   \   00005D   8B83         MOV     DPH,R3
   \   00005F   704E         JNZ     ??osal_build_uint32_4
    260              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], swapped[3] ) );
   \   000061   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000064   78..         MOV     R0,#?V4
   \   000066   12....       LCALL   ?L_SHL
   \   000069   78..         MOV     R0,#?V0
   \   00006B   79..         MOV     R1,#?V4
   \   00006D   12....       LCALL   ?L_ADD
   \   000070   8A82         MOV     DPL,R2
   \   000072   8B83         MOV     DPH,R3
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   F5..         MOV     ?V4,A
   \   000079   E4           CLR     A
   \   00007A   F5..         MOV     ?V5,A
   \   00007C   7410         MOV     A,#0x10
   \   00007E   78..         MOV     R0,#?V4
   \   000080   12....       LCALL   ?L_SHL
   \   000083   78..         MOV     R0,#?V0
   \   000085   79..         MOV     R1,#?V4
   \   000087   12....       LCALL   ?L_ADD
   \   00008A   8A82         MOV     DPL,R2
   \   00008C   8B83         MOV     DPH,R3
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   F5..         MOV     ?V4,A
   \   000094   E4           CLR     A
   \   000095   F5..         MOV     ?V6,A
   \   000097   7418         MOV     A,#0x18
   \                     ??osal_build_uint32_1:
   \   000099   78..         MOV     R0,#?V4
   \   00009B   12....       LCALL   ?L_SHL
   \   00009E   78..         MOV     R0,#?V0
   \   0000A0   79..         MOV     R1,#?V4
   \   0000A2   12....       LCALL   ?L_ADD
   \   0000A5   AA..         MOV     R2,?V0
   \   0000A7   AB..         MOV     R3,?V1
   \   0000A9   AC..         MOV     R4,?V2
   \   0000AB   AD..         MOV     R5,?V3
   \   0000AD   8006         SJMP    ??osal_build_uint32_3
    261            else
    262              return ( (uint32)swapped[0] );
   \                     ??osal_build_uint32_4:
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   FA           MOV     R2,A
   \   0000B1   E4           CLR     A
   \   0000B2   FB           MOV     R3,A
   \   0000B3   FC           MOV     R4,A
   \   0000B4   FD           MOV     R5,A
   \                     ??osal_build_uint32_3:
   \   0000B5   02....       LJMP    ?Subroutine2 & 0xFFFF
    263          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000003   A3           INC     DPTR
   \   000004   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000007   7408         MOV     A,#0x8
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   E4           CLR     A
   \   000004   F5..         MOV     ?V1,A
   \   000006   F5..         MOV     ?V2,A
   \   000008   F5..         MOV     ?V3,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   E4           CLR     A
   \   000004   F5..         MOV     ?V5,A
   \   000006   F5..         MOV     ?V6,A
   \   000008   F5..         MOV     ?V7,A
   \   00000A   22           RET
    264          
    265          #if !defined ( ZBIT ) && !defined ( ZBIT2 ) && !defined (UBIT)
    266          /*********************************************************************
    267           * @fn      _ltoa
    268           *
    269           * @brief
    270           *
    271           *   convert a long unsigned int to a string.
    272           *
    273           * @param  l - long to convert
    274           * @param  buf - buffer to convert to
    275           * @param  radix - 10 dec, 16 hex
    276           *
    277           * @return  pointer to buffer
    278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    279          unsigned char * _ltoa(unsigned long l, unsigned char *buf, unsigned char radix)
   \                     _ltoa:
    280          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 37
   \   000005   74DB         MOV     A,#-0x25
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7403         MOV     A,#0x3
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   EC           MOV     A,R4
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   ED           MOV     A,R5
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E9           MOV     A,R1
   \   000020   F0           MOVX    @DPTR,A
    281          #if defined( __GNUC__ )
    282            return ( (char*)ltoa( l, buf, radix ) );
    283          #else
    284            unsigned char tmp1[10] = "", tmp2[10] = "", tmp3[10] = "";
   \   000021   90....       MOV     DPTR,#`?<Constant "">`
   \   000024   7407         MOV     A,#0x7
   \   000026   12....       LCALL   ?XSTACK_DISP102_8
   \   000029   740A         MOV     A,#0xa
   \   00002B   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   00002E   90....       MOV     DPTR,#`?<Constant "">_1`
   \   000031   740A         MOV     A,#0xa
   \   000033   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000036   90....       MOV     DPTR,#`?<Constant "">_2`
   \   000039   740A         MOV     A,#0xa
   \   00003B   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    285            unsigned short num1, num2, num3;
    286            unsigned char i;
    287          
    288            buf[0] = '\0';
   \   00003E   7435         MOV     A,#0x35
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000046   E4           CLR     A
   \   000047   F0           MOVX    @DPTR,A
    289          
    290            if ( radix == 10 )
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   640A         XRL     A,#0xa
   \   000050   6003         JZ      $+5
   \   000052   02....       LJMP    ??_ltoa_0 & 0xFFFF
    291            {
    292              num1 = l % 10000;
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   78..         MOV     R0,#?V4
   \   00005C   12....       LCALL   ?L_MOV_X
   \   00005F   90....       MOV     DPTR,#__Constant_2710
   \   000062   78..         MOV     R0,#?V0
   \   000064   12....       LCALL   ?L_MOV_X
   \   000067   78..         MOV     R0,#?V4
   \   000069   79..         MOV     R1,#?V0
   \   00006B   12....       LCALL   ?UL_DIV_MOD
   \   00006E   85..82       MOV     DPL,?XSP + 0
   \   000071   85..83       MOV     DPH,?XSP + 1
   \   000074   E5..         MOV     A,?V0
   \   000076   F0           MOVX    @DPTR,A
   \   000077   A3           INC     DPTR
   \   000078   E5..         MOV     A,?V1
   \   00007A   F0           MOVX    @DPTR,A
    293              num2 = (l / 10000) % 10000;
   \   00007B   7403         MOV     A,#0x3
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   78..         MOV     R0,#?V4
   \   000082   12....       LCALL   ?L_MOV_X
   \   000085   90....       MOV     DPTR,#__Constant_2710
   \   000088   78..         MOV     R0,#?V0
   \   00008A   12....       LCALL   ?L_MOV_X
   \   00008D   78..         MOV     R0,#?V4
   \   00008F   79..         MOV     R1,#?V0
   \   000091   12....       LCALL   ?UL_DIV_MOD
   \   000094   90....       MOV     DPTR,#__Constant_2710
   \   000097   78..         MOV     R0,#?V0
   \   000099   12....       LCALL   ?L_MOV_X
   \   00009C   78..         MOV     R0,#?V4
   \   00009E   79..         MOV     R1,#?V0
   \   0000A0   12....       LCALL   ?UL_DIV_MOD
   \   0000A3   AE..         MOV     R6,?V0
   \   0000A5   AF..         MOV     R7,?V1
    294              num3 = (unsigned short)(l / 100000000);
   \   0000A7   7403         MOV     A,#0x3
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   78..         MOV     R0,#?V4
   \   0000AE   12....       LCALL   ?L_MOV_X
   \   0000B1   90....       MOV     DPTR,#__Constant_5f5e100
   \   0000B4   78..         MOV     R0,#?V0
   \   0000B6   12....       LCALL   ?L_MOV_X
   \   0000B9   78..         MOV     R0,#?V4
   \   0000BB   79..         MOV     R1,#?V0
   \   0000BD   12....       LCALL   ?UL_DIV_MOD
   \   0000C0   85....       MOV     ?V6,?V4
   \   0000C3   85....       MOV     ?V7,?V5
    295          
    296              if (num3) _itoa(num3, tmp3, 10);
   \   0000C6   E5..         MOV     A,?V6
   \   0000C8   45..         ORL     A,?V7
   \   0000CA   600E         JZ      ??_ltoa_1
   \   0000CC                ; Setup parameters for call to function _itoa
   \   0000CC   790A         MOV     R1,#0xa
   \   0000CE   741B         MOV     A,#0x1b
   \   0000D0   12....       LCALL   ?XSTACK_DISP102_8
   \   0000D3   AA..         MOV     R2,?V6
   \   0000D5   AB..         MOV     R3,?V7
   \   0000D7   12....       LCALL   `??_itoa::?relay`    ; Banked call to: _itoa
    297              if (num2) _itoa(num2, tmp2, 10);
   \                     ??_ltoa_1:
   \   0000DA   EE           MOV     A,R6
   \   0000DB   4F           ORL     A,R7
   \   0000DC   600E         JZ      ??_ltoa_2
   \   0000DE                ; Setup parameters for call to function _itoa
   \   0000DE   790A         MOV     R1,#0xa
   \   0000E0   7411         MOV     A,#0x11
   \   0000E2   12....       LCALL   ?XSTACK_DISP102_8
   \   0000E5   EE           MOV     A,R6
   \   0000E6   FA           MOV     R2,A
   \   0000E7   EF           MOV     A,R7
   \   0000E8   FB           MOV     R3,A
   \   0000E9   12....       LCALL   `??_itoa::?relay`    ; Banked call to: _itoa
    298              if (num1) _itoa(num1, tmp1, 10);
   \                     ??_ltoa_2:
   \   0000EC   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0000EF   600D         JZ      ??_ltoa_3
   \   0000F1                ; Setup parameters for call to function _itoa
   \   0000F1   790A         MOV     R1,#0xa
   \   0000F3   7407         MOV     A,#0x7
   \   0000F5   12....       LCALL   ?XSTACK_DISP102_8
   \   0000F8   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   0000FB   12....       LCALL   `??_itoa::?relay`    ; Banked call to: _itoa
    299          
    300              if (num3)
   \                     ??_ltoa_3:
   \   0000FE   E5..         MOV     A,?V6
   \   000100   45..         ORL     A,?V7
   \   000102   6036         JZ      ??_ltoa_4
    301              {
    302                strcpy((char*)buf, (char const*)tmp3);
   \   000104                ; Setup parameters for call to function strcpy
   \   000104   741B         MOV     A,#0x1b
   \   000106   12....       LCALL   ?XSTACK_DISP102_8
   \   000109   7435         MOV     A,#0x35
   \   00010B   12....       LCALL   ?XSTACK_DISP0_8
   \   00010E   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000111   12....       LCALL   `??strcpy::?relay`   ; Banked call to: strcpy
    303                for (i = 0; i < 4 - strlen((char const*)tmp2); i++)
   \   000114   75..00       MOV     ?V2,#0x0
   \   000117   8011         SJMP    ??_ltoa_5
    304                  strcat((char*)buf, "0");
   \                     ??_ltoa_6:
   \   000119                ; Setup parameters for call to function strcat
   \   000119   7C..         MOV     R4,#`?<Constant "0">` & 0xff
   \   00011B   7D..         MOV     R5,#(`?<Constant "0">` >> 8) & 0xff
   \   00011D   7435         MOV     A,#0x35
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000125   12....       LCALL   `??strcat::?relay`   ; Banked call to: strcat
   \   000128   05..         INC     ?V2
   \                     ??_ltoa_5:
   \   00012A   85....       MOV     ?V0,?V2
   \   00012D                ; Setup parameters for call to function strlen
   \   00012D   7411         MOV     A,#0x11
   \   00012F   12....       LCALL   ?XSTACK_DISP101_8
   \   000132   12....       LCALL   `??strlen::?relay`   ; Banked call to: strlen
   \   000135   12....       LCALL   ?Subroutine22 & 0xFFFF
    305              }
   \                     ??CrossCallReturnLabel_27:
   \   000138   40DF         JC      ??_ltoa_6
    306              strcat((char*)buf, (char const*)tmp2);
   \                     ??_ltoa_4:
   \   00013A                ; Setup parameters for call to function strcat
   \   00013A   7411         MOV     A,#0x11
   \   00013C   12....       LCALL   ?XSTACK_DISP102_8
   \   00013F   7435         MOV     A,#0x35
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000147   12....       LCALL   `??strcat::?relay`   ; Banked call to: strcat
    307              if (num3 || num2)
   \   00014A   E5..         MOV     A,?V6
   \   00014C   45..         ORL     A,?V7
   \   00014E   7004         JNZ     ??_ltoa_7
   \   000150   EE           MOV     A,R6
   \   000151   4F           ORL     A,R7
   \   000152   6026         JZ      ??_ltoa_8
    308              {
    309                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
   \                     ??_ltoa_7:
   \   000154   75..00       MOV     ?V2,#0x0
   \   000157   8011         SJMP    ??_ltoa_9
    310                  strcat((char*)buf, "0");
   \                     ??_ltoa_10:
   \   000159                ; Setup parameters for call to function strcat
   \   000159   7C..         MOV     R4,#`?<Constant "0">` & 0xff
   \   00015B   7D..         MOV     R5,#(`?<Constant "0">` >> 8) & 0xff
   \   00015D   7435         MOV     A,#0x35
   \   00015F   12....       LCALL   ?XSTACK_DISP0_8
   \   000162   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000165   12....       LCALL   `??strcat::?relay`   ; Banked call to: strcat
   \   000168   05..         INC     ?V2
   \                     ??_ltoa_9:
   \   00016A   85....       MOV     ?V0,?V2
   \   00016D                ; Setup parameters for call to function strlen
   \   00016D   7407         MOV     A,#0x7
   \   00016F   12....       LCALL   ?XSTACK_DISP101_8
   \   000172   12....       LCALL   `??strlen::?relay`   ; Banked call to: strlen
   \   000175   12....       LCALL   ?Subroutine22 & 0xFFFF
    311              }
   \                     ??CrossCallReturnLabel_28:
   \   000178   40DF         JC      ??_ltoa_10
    312              strcat((char*)buf, (char const*)tmp1);
   \                     ??_ltoa_8:
   \   00017A                ; Setup parameters for call to function strcat
   \   00017A   7407         MOV     A,#0x7
   \   00017C   12....       LCALL   ?XSTACK_DISP102_8
   \   00017F   7435         MOV     A,#0x35
   \   000181   12....       LCALL   ?XSTACK_DISP0_8
   \   000184   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000187   12....       LCALL   `??strcat::?relay`   ; Banked call to: strcat
    313              if (!num3 && !num2 && !num1)
   \   00018A   E5..         MOV     A,?V6
   \   00018C   45..         ORL     A,?V7
   \   00018E   7007         JNZ     ??_ltoa_11
   \   000190   EE           MOV     A,R6
   \   000191   4F           ORL     A,R7
   \   000192   7003         JNZ     $+5
   \   000194   02....       LJMP    ??_ltoa_12 & 0xFFFF
    314                strcpy((char*)buf, "0");
    315            }
    316            else if ( radix == 16 )
    317            {
    318              num1 = l & 0x0000FFFF;
    319              num2 = l >> 16;
    320          
    321              if (num2) _itoa(num2, tmp2, 16);
    322              if (num1) _itoa(num1, tmp1, 16);
    323          
    324              if (num2)
    325              {
    326                strcpy((char*)buf,(char const*)tmp2);
    327                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
    328                  strcat((char*)buf, "0");
    329              }
    330              strcat((char*)buf, (char const*)tmp1);
    331              if (!num2 && !num1)
    332                strcpy((char*)buf, "0");
    333            }
    334            else
    335              return NULL;
    336          
    337            return buf;
   \                     ??_ltoa_11:
   \   000197   7435         MOV     A,#0x35
   \   000199   12....       LCALL   ?XSTACK_DISP0_8
   \   00019C   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   00019F   7425         MOV     A,#0x25
   \   0001A1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001A4   02....       LJMP    ?Subroutine2 & 0xFFFF
   \                     ??_ltoa_0:
   \   0001A7   E0           MOVX    A,@DPTR
   \   0001A8   6410         XRL     A,#0x10
   \   0001AA   6003         JZ      $+5
   \   0001AC   02....       LJMP    ??_ltoa_13 & 0xFFFF
   \   0001AF   7403         MOV     A,#0x3
   \   0001B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B4   78..         MOV     R0,#?V0
   \   0001B6   12....       LCALL   ?L_MOV_X
   \   0001B9   85..82       MOV     DPL,?XSP + 0
   \   0001BC   85..83       MOV     DPH,?XSP + 1
   \   0001BF   E5..         MOV     A,?V0
   \   0001C1   F0           MOVX    @DPTR,A
   \   0001C2   A3           INC     DPTR
   \   0001C3   E5..         MOV     A,?V1
   \   0001C5   F0           MOVX    @DPTR,A
   \   0001C6   7403         MOV     A,#0x3
   \   0001C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CB   78..         MOV     R0,#?V0
   \   0001CD   12....       LCALL   ?L_MOV_X
   \   0001D0   7410         MOV     A,#0x10
   \   0001D2   78..         MOV     R0,#?V0
   \   0001D4   12....       LCALL   ?UL_SHR
   \   0001D7   AE..         MOV     R6,?V0
   \   0001D9   AF..         MOV     R7,?V1
   \   0001DB   EE           MOV     A,R6
   \   0001DC   4F           ORL     A,R7
   \   0001DD   600E         JZ      ??_ltoa_14
   \   0001DF                ; Setup parameters for call to function _itoa
   \   0001DF   7910         MOV     R1,#0x10
   \   0001E1   7411         MOV     A,#0x11
   \   0001E3   12....       LCALL   ?XSTACK_DISP102_8
   \   0001E6   EE           MOV     A,R6
   \   0001E7   FA           MOV     R2,A
   \   0001E8   EF           MOV     A,R7
   \   0001E9   FB           MOV     R3,A
   \   0001EA   12....       LCALL   `??_itoa::?relay`    ; Banked call to: _itoa
   \                     ??_ltoa_14:
   \   0001ED   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   0001F0   600D         JZ      ??_ltoa_15
   \   0001F2                ; Setup parameters for call to function _itoa
   \   0001F2   7910         MOV     R1,#0x10
   \   0001F4   7407         MOV     A,#0x7
   \   0001F6   12....       LCALL   ?XSTACK_DISP102_8
   \   0001F9   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0001FC   12....       LCALL   `??_itoa::?relay`    ; Banked call to: _itoa
   \                     ??_ltoa_15:
   \   0001FF   EE           MOV     A,R6
   \   000200   4F           ORL     A,R7
   \   000201   6036         JZ      ??_ltoa_16
   \   000203                ; Setup parameters for call to function strcpy
   \   000203   7411         MOV     A,#0x11
   \   000205   12....       LCALL   ?XSTACK_DISP102_8
   \   000208   7435         MOV     A,#0x35
   \   00020A   12....       LCALL   ?XSTACK_DISP0_8
   \   00020D   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000210   12....       LCALL   `??strcpy::?relay`   ; Banked call to: strcpy
   \   000213   75..00       MOV     ?V2,#0x0
   \   000216   8011         SJMP    ??_ltoa_17
   \                     ??_ltoa_18:
   \   000218                ; Setup parameters for call to function strcat
   \   000218   7C..         MOV     R4,#`?<Constant "0">` & 0xff
   \   00021A   7D..         MOV     R5,#(`?<Constant "0">` >> 8) & 0xff
   \   00021C   7435         MOV     A,#0x35
   \   00021E   12....       LCALL   ?XSTACK_DISP0_8
   \   000221   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000224   12....       LCALL   `??strcat::?relay`   ; Banked call to: strcat
   \   000227   05..         INC     ?V2
   \                     ??_ltoa_17:
   \   000229   85....       MOV     ?V0,?V2
   \   00022C                ; Setup parameters for call to function strlen
   \   00022C   7407         MOV     A,#0x7
   \   00022E   12....       LCALL   ?XSTACK_DISP101_8
   \   000231   12....       LCALL   `??strlen::?relay`   ; Banked call to: strlen
   \   000234   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000237   40DF         JC      ??_ltoa_18
   \                     ??_ltoa_16:
   \   000239                ; Setup parameters for call to function strcat
   \   000239   7407         MOV     A,#0x7
   \   00023B   12....       LCALL   ?XSTACK_DISP102_8
   \   00023E   7435         MOV     A,#0x35
   \   000240   12....       LCALL   ?XSTACK_DISP0_8
   \   000243   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000246   12....       LCALL   `??strcat::?relay`   ; Banked call to: strcat
   \   000249   EE           MOV     A,R6
   \   00024A   4F           ORL     A,R7
   \   00024B   6003         JZ      $+5
   \   00024D   02....       LJMP    ??_ltoa_11 & 0xFFFF
   \                     ??_ltoa_12:
   \   000250   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000253   6003         JZ      $+5
   \   000255   02....       LJMP    ??_ltoa_11 & 0xFFFF
   \   000258                ; Setup parameters for call to function strcpy
   \   000258   7C..         MOV     R4,#`?<Constant "0">` & 0xff
   \   00025A   7D..         MOV     R5,#(`?<Constant "0">` >> 8) & 0xff
   \   00025C   7435         MOV     A,#0x35
   \   00025E   12....       LCALL   ?XSTACK_DISP0_8
   \   000261   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000264   12....       LCALL   `??strcpy::?relay`   ; Banked call to: strcpy
   \   000267   02....       LJMP    ??_ltoa_11 & 0xFFFF
   \                     ??_ltoa_13:
   \   00026A   7A00         MOV     R2,#0x0
   \   00026C   7B00         MOV     R3,#0x0
   \   00026E   02....       LJMP    ??CrossCallReturnLabel_77 & 0xFFFF
    338          #endif
    339          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   8A..         MOV     ?V4,R2
   \   000002   8B..         MOV     ?V5,R3
   \   000004   7404         MOV     A,#0x4
   \   000006   C3           CLR     C
   \   000007   95..         SUBB    A,?V4
   \   000009   F8           MOV     R0,A
   \   00000A   E4           CLR     A
   \   00000B   95..         SUBB    A,?V5
   \   00000D   F9           MOV     R1,A
   \   00000E   C3           CLR     C
   \   00000F   E5..         MOV     A,?V0
   \   000011   98           SUBB    A,R0
   \   000012   E4           CLR     A
   \   000013   99           SUBB    A,R1
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine38_0
   \   000006                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   49           ORL     A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine39_0
   \   000006                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    340          #endif // !defined(ZBIT) && !defined(ZBIT2)
    341          
    342          /*********************************************************************
    343           * @fn        osal_rand
    344           *
    345           * @brief    Random number generator
    346           *
    347           * @param   none
    348           *
    349           * @return  uint16 - new random number
    350           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    351          uint16 osal_rand( void )
   \                     osal_rand:
    352          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    353            return ( Onboard_rand() );
   \   000004                ; Setup parameters for call to function Onboard_rand
   \   000004   12....       LCALL   `??Onboard_rand::?relay`; Banked call to: Onboard_rand
   \   000007   80..         SJMP    ?Subroutine0
    354          }
    355          
    356          /*********************************************************************
    357           * API FUNCTIONS
    358           *********************************************************************/
    359          
    360          /*********************************************************************
    361           * @fn      osal_msg_allocate
    362           *
    363           * @brief
    364           *
    365           *    This function is called by a task to allocate a message buffer
    366           *    into which the task will encode the particular message it wishes
    367           *    to send.  This common buffer scheme is used to strictly limit the
    368           *    creation of message buffers within the system due to RAM size
    369           *    limitations on the microprocessor.   Note that all message buffers
    370           *    are a fixed size (at least initially).  The parameter len is kept
    371           *    in case a message pool with varying fixed message sizes is later
    372           *    created (for example, a pool of message buffers of size LARGE,
    373           *    MEDIUM and SMALL could be maintained and allocated based on request
    374           *    from the tasks).
    375           *
    376           *
    377           * @param   uint8 len  - wanted buffer length
    378           *
    379           *
    380           * @return  pointer to allocated buffer or NULL if allocation failed.
    381           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    382          uint8 * osal_msg_allocate( uint16 len )
   \                     osal_msg_allocate:
    383          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    384            osal_msg_hdr_t *hdr;
    385          
    386            if ( len == 0 )
   \   000009   EE           MOV     A,R6
   \   00000A   4F           ORL     A,R7
   \   00000B   603D         JZ      ??osal_msg_allocate_0
    387              return ( NULL );
    388          
    389            hdr = (osal_msg_hdr_t *) osal_mem_alloc( (short)(len + sizeof( osal_msg_hdr_t )) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   EE           MOV     A,R6
   \   00000E   2405         ADD     A,#0x5
   \   000010   FA           MOV     R2,A
   \   000011   E4           CLR     A
   \   000012   3F           ADDC    A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000017   8A..         MOV     ?V0,R2
   \   000019   8B..         MOV     ?V1,R3
   \   00001B   A8..         MOV     R0,?V0
   \   00001D   A9..         MOV     R1,?V1
    390            if ( hdr )
   \   00001F   E8           MOV     A,R0
   \   000020   49           ORL     A,R1
   \   000021   6027         JZ      ??osal_msg_allocate_0
    391            {
    392              hdr->next = NULL;
   \   000023   8882         MOV     DPL,R0
   \   000025   8983         MOV     DPH,R1
   \   000027   E4           CLR     A
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   F0           MOVX    @DPTR,A
    393              hdr->len = len;
   \   00002B   8882         MOV     DPL,R0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   EE           MOV     A,R6
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   EF           MOV     A,R7
   \   000035   F0           MOVX    @DPTR,A
    394              hdr->dest_id = TASK_NO_TASK;
   \   000036   8882         MOV     DPL,R0
   \   000038   8983         MOV     DPH,R1
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   74FF         MOV     A,#-0x1
   \   000040   F0           MOVX    @DPTR,A
    395              return ( (uint8 *) (hdr + 1) );
   \   000041   E8           MOV     A,R0
   \   000042   2405         ADD     A,#0x5
   \   000044   FA           MOV     R2,A
   \   000045   E4           CLR     A
   \   000046   39           ADDC    A,R1
   \   000047   FB           MOV     R3,A
   \   000048   8004         SJMP    ??osal_msg_allocate_1
    396            }
    397            else
    398              return ( NULL );
   \                     ??osal_msg_allocate_0:
   \   00004A   7A00         MOV     R2,#0x0
   \   00004C   7B00         MOV     R3,#0x0
   \                     ??osal_msg_allocate_1:
   \   00004E   02....       LJMP    ?Subroutine3 & 0xFFFF
    399          }
    400          
    401          /*********************************************************************
    402           * @fn      osal_msg_deallocate
    403           *
    404           * @brief
    405           *
    406           *    This function is used to deallocate a message buffer. This function
    407           *    is called by a task (or processing element) after it has finished
    408           *    processing a received message.
    409           *
    410           *
    411           * @param   uint8 *msg_ptr - pointer to new message buffer
    412           *
    413           * @return  SUCCESS, INVALID_MSG_POINTER
    414           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    415          uint8 osal_msg_deallocate( uint8 *msg_ptr )
   \                     osal_msg_deallocate:
    416          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    417            uint8 *x;
    418          
    419            if ( msg_ptr == NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   7004         JNZ     ??osal_msg_deallocate_0
    420              return ( INVALID_MSG_POINTER );
   \   000008   7905         MOV     R1,#0x5
   \   00000A   8016         SJMP    ??osal_msg_deallocate_1
    421          
    422            // don't deallocate queued buffer
    423            if ( OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_deallocate_0:
   \   00000C   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00000F   6004         JZ      ??osal_msg_deallocate_2
    424              return ( MSG_BUFFER_NOT_AVAIL );
   \   000011   7904         MOV     R1,#0x4
   \   000013   800D         SJMP    ??osal_msg_deallocate_1
    425          
    426            x = (uint8 *)((uint8 *)msg_ptr - sizeof( osal_msg_hdr_t ));
    427          
    428            osal_mem_free( (void *)x );
   \                     ??osal_msg_deallocate_2:
   \   000015                ; Setup parameters for call to function osal_mem_free
   \   000015   EA           MOV     A,R2
   \   000016   24FB         ADD     A,#-0x5
   \   000018   FA           MOV     R2,A
   \   000019   EB           MOV     A,R3
   \   00001A   34FF         ADDC    A,#-0x1
   \   00001C   FB           MOV     R3,A
   \   00001D   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    429          
    430            return ( SUCCESS );
   \   000020   7900         MOV     R1,#0x0
   \                     ??osal_msg_deallocate_1:
   \   000022                REQUIRE ?Subroutine0
   \   000022                ; // Fall through to label ?Subroutine0
    431          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F4           CPL     A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   EA           MOV     A,R2
   \   000001   24FF         ADD     A,#-0x1
   \   000003   F582         MOV     DPL,A
   \   000005   EB           MOV     A,R3
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET
    432          
    433          /*********************************************************************
    434           * @fn      osal_msg_send
    435           *
    436           * @brief
    437           *
    438           *    This function is called by a task to send a command message to
    439           *    another task or processing element.  The sending_task field must
    440           *    refer to a valid task, since the task ID will be used
    441           *    for the response message.  This function will also set a message
    442           *    ready event in the destination tasks event list.
    443           *
    444           *
    445           * @param   uint8 destination_task - Send msg to Task ID
    446           * @param   uint8 *msg_ptr - pointer to new message buffer
    447           *
    448           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    449           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    450          uint8 osal_msg_send( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_send:
    451          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    452            return ( osal_msg_enqueue_push( destination_task, msg_ptr, FALSE ) );
   \   000005                ; Setup parameters for call to function osal_msg_enqueue_push
   \   000005   7C00         MOV     R4,#0x0
   \   000007                REQUIRE ?Subroutine6
   \   000007                ; // Fall through to label ?Subroutine6
    453          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   `??osal_msg_enqueue_push::?relay`; Banked call to: osal_msg_enqueue_push
   \   000003   80..         SJMP    ??Subroutine32_0
    454          
    455          /*********************************************************************
    456           * @fn      osal_msg_push_front
    457           *
    458           * @brief
    459           *
    460           *    This function is called by a task to push a command message
    461           *    to the head of the OSAL queue. The destination_task field
    462           *    must refer to a valid task, since the task ID will be used to
    463           *    send the message to. This function will also set a message
    464           *    ready event in the destination task's event list.
    465           *
    466           * @param   uint8 destination_task - Send msg to Task ID
    467           * @param   uint8 *msg_ptr - pointer to message buffer
    468           *
    469           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    470           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    471          uint8 osal_msg_push_front( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_push_front:
    472          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    473            return ( osal_msg_enqueue_push( destination_task, msg_ptr, TRUE ) );
   \   000005                ; Setup parameters for call to function osal_msg_enqueue_push
   \   000005   7C01         MOV     R4,#0x1
   \   000007   80..         SJMP    ?Subroutine6
    474          }
    475          
    476          /*********************************************************************
    477           * @fn      osal_msg_enqueue_push
    478           *
    479           * @brief
    480           *
    481           *    This function is called by a task to either enqueue (append to
    482           *    queue) or push (prepend to queue) a command message to the OSAL
    483           *    queue. The destination_task field must refer to a valid task,
    484           *    since the task ID will be used to send the message to. This 
    485           *    function will also set a message ready event in the destination
    486           *    task's event list.
    487           *
    488           * @param   uint8 destination_task - Send msg to Task ID
    489           * @param   uint8 *msg_ptr - pointer to message buffer
    490           * @param   uint8 push - TRUE to push, otherwise enqueue
    491           *
    492           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    493           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    494          static uint8 osal_msg_enqueue_push( uint8 destination_task, uint8 *msg_ptr, uint8 push )
   \                     osal_msg_enqueue_push:
    495          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EC           MOV     A,R4
   \   000008   FF           MOV     R7,A
    496            if ( msg_ptr == NULL )
   \   000009   EA           MOV     A,R2
   \   00000A   4B           ORL     A,R3
   \   00000B   6025         JZ      ??osal_msg_enqueue_push_0
    497            {
    498              return ( INVALID_MSG_POINTER );
    499            }
    500          
    501            if ( destination_task >= tasksCnt )
   \   00000D   90....       MOV     DPTR,#tasksCnt
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F8           MOV     R0,A
   \   000012   EE           MOV     A,R6
   \   000013   C3           CLR     C
   \   000014   98           SUBB    A,R0
   \   000015   4007         JC      ??osal_msg_enqueue_push_1
    502            {
    503              osal_msg_deallocate( msg_ptr );
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   12....       LCALL   `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    504              return ( INVALID_TASK );
   \   00001A   7903         MOV     R1,#0x3
   \   00001C   8042         SJMP    ??osal_msg_enqueue_push_2
    505            }
    506          
    507            // Check the message header
    508            if ( OSAL_MSG_NEXT( msg_ptr ) != NULL ||
    509                 OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_enqueue_push_1:
   \   00001E   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000021   EB           MOV     A,R3
   \   000022   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000025   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000028   7005         JNZ     ??osal_msg_enqueue_push_3
   \   00002A   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00002D   6007         JZ      ??osal_msg_enqueue_push_4
    510            {
    511              osal_msg_deallocate( msg_ptr );
   \                     ??osal_msg_enqueue_push_3:
   \   00002F                ; Setup parameters for call to function osal_msg_deallocate
   \   00002F   12....       LCALL   `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    512              return ( INVALID_MSG_POINTER );
   \                     ??osal_msg_enqueue_push_0:
   \   000032   7905         MOV     R1,#0x5
   \   000034   802A         SJMP    ??osal_msg_enqueue_push_2
    513            }
    514          
    515            OSAL_MSG_ID( msg_ptr ) = destination_task;
   \                     ??osal_msg_enqueue_push_4:
   \   000036   EE           MOV     A,R6
   \   000037   F0           MOVX    @DPTR,A
    516          
    517            if ( push == TRUE )
   \   000038   7401         MOV     A,#0x1
   \   00003A   6F           XRL     A,R7
   \   00003B   700D         JNZ     ??osal_msg_enqueue_push_5
    518            {
    519              // prepend the message
    520              osal_msg_push( &osal_qHead, msg_ptr );
   \   00003D                ; Setup parameters for call to function osal_msg_push
   \   00003D   EA           MOV     A,R2
   \   00003E   FC           MOV     R4,A
   \   00003F   EB           MOV     A,R3
   \   000040   FD           MOV     R5,A
   \   000041   7A..         MOV     R2,#osal_qHead & 0xff
   \   000043   7B..         MOV     R3,#(osal_qHead >> 8) & 0xff
   \   000045   12....       LCALL   `??osal_msg_push::?relay`; Banked call to: osal_msg_push
   \   000048   800B         SJMP    ??osal_msg_enqueue_push_6
    521            }
    522            else
    523            {
    524              // append the message
    525              osal_msg_enqueue( &osal_qHead, msg_ptr );
   \                     ??osal_msg_enqueue_push_5:
   \   00004A                ; Setup parameters for call to function osal_msg_enqueue
   \   00004A   EA           MOV     A,R2
   \   00004B   FC           MOV     R4,A
   \   00004C   EB           MOV     A,R3
   \   00004D   FD           MOV     R5,A
   \   00004E   7A..         MOV     R2,#osal_qHead & 0xff
   \   000050   7B..         MOV     R3,#(osal_qHead >> 8) & 0xff
   \   000052   12....       LCALL   `??osal_msg_enqueue::?relay`; Banked call to: osal_msg_enqueue
    526            }
    527          
    528            // Signal the task that a message is waiting
    529            osal_set_event( destination_task, SYS_EVENT_MSG );
   \                     ??osal_msg_enqueue_push_6:
   \   000055                ; Setup parameters for call to function osal_set_event
   \   000055   7A00         MOV     R2,#0x0
   \   000057   7B80         MOV     R3,#-0x80
   \   000059   EE           MOV     A,R6
   \   00005A   F9           MOV     R1,A
   \   00005B   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
    530          
    531            return ( SUCCESS );
   \   00005E   7900         MOV     R1,#0x0
   \                     ??osal_msg_enqueue_push_2:
   \   000060   80..         SJMP    ??Subroutine32_0
    532          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   EA           MOV     A,R2
   \   000001                REQUIRE ??Subroutine37_0
   \   000001                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   24FB         ADD     A,#-0x5
   \   000002   F582         MOV     DPL,A
   \   000004   22           RET
    533          
    534          /*********************************************************************
    535           * @fn      osal_msg_receive
    536           *
    537           * @brief
    538           *
    539           *    This function is called by a task to retrieve a received command
    540           *    message. The calling task must deallocate the message buffer after
    541           *    processing the message using the osal_msg_deallocate() call.
    542           *
    543           * @param   uint8 task_id - receiving tasks ID
    544           *
    545           * @return  *uint8 - message information or NULL if no message
    546           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    547          uint8 *osal_msg_receive( uint8 task_id )
   \                     osal_msg_receive:
    548          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
    549            osal_msg_hdr_t *listHdr;
    550            osal_msg_hdr_t *prevHdr = NULL;
   \   000007   75..00       MOV     ?V2,#0x0
   \   00000A   75..00       MOV     ?V3,#0x0
    551            osal_msg_hdr_t *foundHdr = NULL;
   \   00000D   7E00         MOV     R6,#0x0
   \   00000F   7F00         MOV     R7,#0x0
    552            halIntState_t   intState;
    553          
    554            // Hold off interrupts
    555            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000011   A2AF         MOV     C,0xa8.7
   \   000013   E4           CLR     A
   \   000014   33           RLC     A
   \   000015   F5..         MOV     ?V1,A
   \   000017   C2AF         CLR     0xa8.7
    556          
    557            // Point to the top of the queue
    558            listHdr = osal_qHead;
   \   000019   90....       MOV     DPTR,#osal_qHead
   \   00001C   800B         SJMP    ??CrossCallReturnLabel_53
    559          
    560            // Look through the queue for a message that belongs to the asking task
    561            while ( listHdr != NULL )
    562            {
    563              if ( (listHdr - 1)->dest_id == task_id )
    564              {
    565                if ( foundHdr == NULL )
    566                {
    567                  // Save the first one
    568                  foundHdr = listHdr;
    569                }
    570                else
    571                {
    572                  // Second msg found, stop looking
    573                  break;
    574                }
    575              }
    576              if ( foundHdr == NULL )
   \                     ??osal_msg_receive_0:
   \   00001E   EE           MOV     A,R6
   \   00001F   4F           ORL     A,R7
   \   000020   7004         JNZ     ??osal_msg_receive_1
    577              {
    578                prevHdr = listHdr;
   \   000022   88..         MOV     ?V2,R0
   \   000024   89..         MOV     ?V3,R1
    579              }
    580              listHdr = OSAL_MSG_NEXT( listHdr );
   \                     ??osal_msg_receive_1:
   \   000026   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000029   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00002C   6020         JZ      ??osal_msg_receive_2
   \   00002E   E8           MOV     A,R0
   \   00002F   24FF         ADD     A,#-0x1
   \   000031   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000034   E0           MOVX    A,@DPTR
   \   000035   65..         XRL     A,?V0
   \   000037   70E5         JNZ     ??osal_msg_receive_0
   \   000039   EE           MOV     A,R6
   \   00003A   4F           ORL     A,R7
   \   00003B   7006         JNZ     ??osal_msg_receive_3
   \   00003D   E8           MOV     A,R0
   \   00003E   FE           MOV     R6,A
   \   00003F   E9           MOV     A,R1
   \   000040   FF           MOV     R7,A
   \   000041   80E3         SJMP    ??osal_msg_receive_1
    581            }
    582          
    583            // Is there more than one?
    584            if ( listHdr != NULL )
    585            {
    586              // Yes, Signal the task that a message is waiting
    587              osal_set_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_3:
   \   000043                ; Setup parameters for call to function osal_set_event
   \   000043   7A00         MOV     R2,#0x0
   \   000045   7B80         MOV     R3,#-0x80
   \   000047   A9..         MOV     R1,?V0
   \   000049   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   \   00004C   800D         SJMP    ??osal_msg_receive_4
    588            }
    589            else
    590            {
    591              // No more
    592              osal_clear_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_2:
   \   00004E                ; Setup parameters for call to function osal_clear_event
   \   00004E   7A00         MOV     R2,#0x0
   \   000050   7B80         MOV     R3,#-0x80
   \   000052   A9..         MOV     R1,?V0
   \   000054   12....       LCALL   `??osal_clear_event::?relay`; Banked call to: osal_clear_event
    593            }
    594          
    595            // Did we find a message?
    596            if ( foundHdr != NULL )
   \   000057   EE           MOV     A,R6
   \   000058   4F           ORL     A,R7
   \   000059   6015         JZ      ??osal_msg_receive_5
    597            {
    598              // Take out of the link list
    599              osal_msg_extract( &osal_qHead, foundHdr, prevHdr );
   \                     ??osal_msg_receive_4:
   \   00005B                ; Setup parameters for call to function osal_msg_extract
   \   00005B   78..         MOV     R0,#?V2
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   EE           MOV     A,R6
   \   000061   FC           MOV     R4,A
   \   000062   EF           MOV     A,R7
   \   000063   FD           MOV     R5,A
   \   000064   7A..         MOV     R2,#osal_qHead & 0xff
   \   000066   7B..         MOV     R3,#(osal_qHead >> 8) & 0xff
   \   000068   12....       LCALL   `??osal_msg_extract::?relay`; Banked call to: osal_msg_extract
   \   00006B   7402         MOV     A,#0x2
   \   00006D   12....       LCALL   ?DEALLOC_XSTACK8
    600            }
    601          
    602            // Release interrupts
    603            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_receive_5:
   \   000070   E5..         MOV     A,?V1
   \   000072   A2E0         MOV     C,0xE0 /* A   */.0
   \   000074   92AF         MOV     0xa8.7,C
    604          
    605            return ( (uint8*) foundHdr );
   \   000076   EE           MOV     A,R6
   \   000077   FA           MOV     R2,A
   \   000078   EF           MOV     A,R7
   \   000079   FB           MOV     R3,A
   \   00007A                REQUIRE ?Subroutine4
   \   00007A                REQUIRE _A_IEN0
   \   00007A                ; // Fall through to label ?Subroutine4
    606          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E8           MOV     A,R0
   \   000001   24FB         ADD     A,#-0x5
   \   000003                REQUIRE ??Subroutine35_0
   \   000003                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   F582         MOV     DPL,A
   \   000002   E9           MOV     A,R1
   \   000003                REQUIRE ??Subroutine36_0
   \   000003                ; // Fall through to label ??Subroutine36_0
    607          
    608          /**************************************************************************************************
    609           * @fn          osal_msg_find
    610           *
    611           * @brief       This function finds in place an OSAL message matching the task_id and event
    612           *              parameters.
    613           *
    614           * input parameters
    615           *
    616           * @param       task_id - The OSAL task id that the enqueued OSAL message must match.
    617           * @param       event - The OSAL event id that the enqueued OSAL message must match.
    618           *
    619           * output parameters
    620           *
    621           * None.
    622           *
    623           * @return      NULL if no match, otherwise an in place pointer to the matching OSAL message.
    624           **************************************************************************************************
    625           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    626          osal_event_hdr_t *osal_msg_find(uint8 task_id, uint8 event)
   \                     osal_msg_find:
    627          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   EA           MOV     A,R2
   \   000005   FC           MOV     R4,A
    628            osal_msg_hdr_t *pHdr;
    629            halIntState_t intState;
    630          
    631            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000006   A2AF         MOV     C,0xa8.7
   \   000008   E4           CLR     A
   \   000009   33           RLC     A
   \   00000A   F8           MOV     R0,A
   \   00000B   C2AF         CLR     0xa8.7
    632          
    633            pHdr = osal_qHead;  // Point to the top of the queue.
   \   00000D   90....       MOV     DPTR,#osal_qHead
   \   000010   8007         SJMP    ??CrossCallReturnLabel_48
    634          
    635            // Look through the queue for a message that matches the task_id and event parameters.
    636            while (pHdr != NULL)
    637            {
    638              if (((pHdr-1)->dest_id == task_id) && (((osal_event_hdr_t *)pHdr)->event == event))
    639              {
    640                break;
    641              }
    642          
    643              pHdr = OSAL_MSG_NEXT(pHdr);
   \                     ??osal_msg_find_0:
   \   000012   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000015   EB           MOV     A,R3
   \   000016   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000019   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00001C   4B           ORL     A,R3
   \   00001D   600F         JZ      ??osal_msg_find_1
   \   00001F   12....       LCALL   ?Subroutine19 & 0xFFFF
    644            }
   \                     ??CrossCallReturnLabel_21:
   \   000022   E0           MOVX    A,@DPTR
   \   000023   69           XRL     A,R1
   \   000024   70EC         JNZ     ??osal_msg_find_0
   \   000026   8A82         MOV     DPL,R2
   \   000028   8B83         MOV     DPH,R3
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   6C           XRL     A,R4
   \   00002C   70E4         JNZ     ??osal_msg_find_0
    645          
    646            HAL_EXIT_CRITICAL_SECTION(intState);  // Release interrupts.
   \                     ??osal_msg_find_1:
   \   00002E   E8           MOV     A,R0
   \   00002F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000031   92AF         MOV     0xa8.7,C
    647          
    648            return (osal_event_hdr_t *)pHdr;
   \   000033   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000036                REQUIRE _A_IEN0
    649          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   EA           MOV     A,R2
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000003   22           RET
    650          
    651          /**************************************************************************************************
    652           * @fn          osal_msg_count
    653           *
    654           * @brief       This function counts the number of messages, in the OSAL message queue with a
    655           *              a given task ID and message event type.
    656           *
    657           * input parameters
    658           *
    659           * @param       task_id - The OSAL task id that the enqueued OSAL message must match.
    660           * @param       event - The OSAL event id that the enqueued OSAL message must match. 0xFF for 
    661           *              all events.
    662           *
    663           * output parameters
    664           *
    665           * None.
    666           *
    667           * @return      The number of OSAL messages that match the task ID and Event.
    668           **************************************************************************************************
    669           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   A2E0         MOV     C,0xE0 /* A   */.0
   \   000002                REQUIRE ??Subroutine31_0
   \   000002                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   92AF         MOV     0xa8.7,C
   \   000002                REQUIRE ??Subroutine32_0
   \   000002                ; // Fall through to label ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    670          uint8 osal_msg_count( uint8 task_id, uint8 event )
   \                     osal_msg_count:
    671          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FB           MOV     R3,A
    672            uint8 count = 0;
   \   000007   7900         MOV     R1,#0x0
    673            osal_msg_hdr_t *pHdr;
    674            halIntState_t intState;
    675          
    676            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   33           RLC     A
   \   00000D   F8           MOV     R0,A
   \   00000E   C2AF         CLR     0xa8.7
    677          
    678            pHdr = osal_qHead;  // Point to the top of the queue.
   \   000010   90....       MOV     DPTR,#osal_qHead
   \   000013   801B         SJMP    ??CrossCallReturnLabel_49
    679          
    680            // Look through the queue for a message that matches the task_id and event parameters.
    681            while (pHdr != NULL)
    682            {
    683              if ( ((pHdr-1)->dest_id == task_id) 
    684                  && ((event == 0xFF) || (((osal_event_hdr_t *)pHdr)->event == event)) )
   \                     ??osal_msg_count_0:
   \   000015   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000018   E0           MOVX    A,@DPTR
   \   000019   6B           XRL     A,R3
   \   00001A   700E         JNZ     ??osal_msg_count_1
   \   00001C   74FF         MOV     A,#-0x1
   \   00001E   6A           XRL     A,R2
   \   00001F   6008         JZ      ??osal_msg_count_2
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   E0           MOVX    A,@DPTR
   \   000026   6A           XRL     A,R2
   \   000027   7001         JNZ     ??osal_msg_count_1
    685              {
    686                count++;
   \                     ??osal_msg_count_2:
   \   000029   09           INC     R1
    687              }
    688          
    689              pHdr = OSAL_MSG_NEXT(pHdr);
   \                     ??osal_msg_count_1:
   \   00002A   12....       LCALL   ?Subroutine25 & 0xFFFF
    690            }
   \                     ??CrossCallReturnLabel_32:
   \   00002D   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000030   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000033   4D           ORL     A,R5
   \   000034   70DF         JNZ     ??osal_msg_count_0
    691          
    692            HAL_EXIT_CRITICAL_SECTION(intState);  // Release interrupts.
   \   000036   E8           MOV     A,R0
   \   000037   02....       LJMP    ??Subroutine30_0 & 0xFFFF
   \   00003A                REQUIRE _A_IEN0
    693          
    694            return ( count );
    695          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   EC           MOV     A,R4
   \   000001   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000004   ED           MOV     A,R5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   EC           MOV     A,R4
   \   000001   24FF         ADD     A,#-0x1
   \   000003   F582         MOV     DPL,A
   \   000005   ED           MOV     A,R5
   \   000006   34FF         ADDC    A,#-0x1
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET
    696          
    697          /*********************************************************************
    698           * @fn      osal_msg_enqueue
    699           *
    700           * @brief
    701           *
    702           *    This function enqueues an OSAL message into an OSAL queue.
    703           *
    704           * @param   osal_msg_q_t *q_ptr - OSAL queue
    705           * @param   void *msg_ptr  - OSAL message
    706           *
    707           * @return  none
    708           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002                REQUIRE ??Subroutine30_0
   \   000002                ; // Fall through to label ??Subroutine30_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    709          void osal_msg_enqueue( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_enqueue:
    710          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    711            void *list;
    712            halIntState_t intState;
    713          
    714            // Hold off interrupts
    715            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   33           RLC     A
   \   000009   FE           MOV     R6,A
   \   00000A   C2AF         CLR     0xa8.7
    716          
    717            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   00000C   12....       LCALL   ?Subroutine23 & 0xFFFF
    718            // If first message in queue
    719            if ( *q_ptr == NULL )
   \                     ??CrossCallReturnLabel_30:
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000016   7009         JNZ     ??CrossCallReturnLabel_45
    720            {
    721              *q_ptr = msg_ptr;
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   800F         SJMP    ??CrossCallReturnLabel_55
    722            }
    723            else
    724            {
    725              // Find end of queue
    726              for ( list = *q_ptr; OSAL_MSG_NEXT( list ) != NULL; list = OSAL_MSG_NEXT( list ) );
   \                     ??osal_msg_enqueue_0:
   \   00001E   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000021   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000024   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000027   4B           ORL     A,R3
   \   000028   70F4         JNZ     ??osal_msg_enqueue_0
    727          
    728              // Add message to end of queue
    729              OSAL_MSG_NEXT( list ) = msg_ptr;
   \   00002A   12....       LCALL   ?Subroutine24 & 0xFFFF
    730            }
   \                     ??CrossCallReturnLabel_55:
   \   00002D   EC           MOV     A,R4
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   ED           MOV     A,R5
   \   000031   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   000034                REQUIRE _A_IEN0
    731          
    732            // Re-enable interrupts
    733            HAL_EXIT_CRITICAL_SECTION(intState);
    734          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E8           MOV     A,R0
   \   000001   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000004   E9           MOV     A,R1
   \   000005                REQUIRE ??Subroutine33_0
   \   000005                ; // Fall through to label ??Subroutine33_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine33_0:
   \   000000   34FF         ADDC    A,#-0x1
   \   000002   F583         MOV     DPH,A
   \   000004                REQUIRE ??Subroutine34_0
   \   000004                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   EC           MOV     A,R4
   \   000001   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000004   ED           MOV     A,R5
   \   000005   34FF         ADDC    A,#-0x1
   \   000007   F583         MOV     DPH,A
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   22           RET
    735          
    736          /*********************************************************************
    737           * @fn      osal_msg_dequeue
    738           *
    739           * @brief
    740           *
    741           *    This function dequeues an OSAL message from an OSAL queue.
    742           *
    743           * @param   osal_msg_q_t *q_ptr - OSAL queue
    744           *
    745           * @return  void * - pointer to OSAL message or NULL of queue is empty.
    746           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    747          void *osal_msg_dequeue( osal_msg_q_t *q_ptr )
   \                     osal_msg_dequeue:
    748          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
    749            void *msg_ptr = NULL;
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   7B00         MOV     R3,#0x0
    750            halIntState_t intState;
    751          
    752            // Hold off interrupts
    753            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   33           RLC     A
   \   000011   FE           MOV     R6,A
   \   000012   C2AF         CLR     0xa8.7
    754          
    755            if ( *q_ptr != NULL )
   \   000014   8882         MOV     DPL,R0
   \   000016   8983         MOV     DPH,R1
   \   000018   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   00001B   4D           ORL     A,R5
   \   00001C   6032         JZ      ??osal_msg_dequeue_0
    756            {
    757              // Dequeue message
    758              msg_ptr = *q_ptr;
   \   00001E   8882         MOV     DPL,R0
   \   000020   8983         MOV     DPH,R1
   \   000022   12....       LCALL   ?Subroutine13 & 0xFFFF
    759              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \                     ??CrossCallReturnLabel_11:
   \   000025   24FB         ADD     A,#-0x5
   \   000027   FC           MOV     R4,A
   \   000028   EB           MOV     A,R3
   \   000029   34FF         ADDC    A,#-0x1
   \   00002B   FD           MOV     R5,A
   \   00002C   8C82         MOV     DPL,R4
   \   00002E   8D83         MOV     DPH,R5
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F5..         MOV     ?V0,A
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V1,A
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \   00003B   E5..         MOV     A,?V0
   \   00003D   F0           MOVX    @DPTR,A
   \   00003E   A3           INC     DPTR
   \   00003F   E5..         MOV     A,?V1
   \   000041   F0           MOVX    @DPTR,A
    760              OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000042   8C82         MOV     DPL,R4
   \   000044   8D83         MOV     DPH,R5
   \   000046   E4           CLR     A
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
    761              OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00004A   12....       LCALL   ?Subroutine19 & 0xFFFF
    762            }
   \                     ??CrossCallReturnLabel_22:
   \   00004D   74FF         MOV     A,#-0x1
   \   00004F   F0           MOVX    @DPTR,A
    763          
    764            // Re-enable interrupts
    765            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_dequeue_0:
   \   000050   EE           MOV     A,R6
   \   000051   A2E0         MOV     C,0xE0 /* A   */.0
   \   000053   92AF         MOV     0xa8.7,C
    766          
    767            return msg_ptr;
   \   000055                REQUIRE ?Subroutine3
   \   000055                REQUIRE _A_IEN0
   \   000055                ; // Fall through to label ?Subroutine3
    768          }
    769          
    770          /*********************************************************************
    771           * @fn      osal_msg_push
    772           *
    773           * @brief
    774           *
    775           *    This function pushes an OSAL message to the head of an OSAL
    776           *    queue.
    777           *
    778           * @param   osal_msg_q_t *q_ptr - OSAL queue
    779           * @param   void *msg_ptr  - OSAL message
    780           *
    781           * @return  none
    782           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    783          void osal_msg_push( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_push:
    784          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    785            halIntState_t intState;
    786          
    787            // Hold off interrupts
    788            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A8A8         MOV     R0,0xa8+0x0
   \   000007   C2AF         CLR     0xa8.7
    789          
    790            // Push message to head of queue
    791            OSAL_MSG_NEXT( msg_ptr ) = *q_ptr;
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FE           MOV     R6,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FF           MOV     R7,A
   \   000012   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000015   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000018   EE           MOV     A,R6
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   EF           MOV     A,R7
   \   00001C   F0           MOVX    @DPTR,A
    792            *q_ptr = msg_ptr;
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   EC           MOV     A,R4
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   ED           MOV     A,R5
   \   000025   12....       LCALL   ?Subroutine17 & 0xFFFF
    793          
    794            // Re-enable interrupts
    795            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_17:
   \   000028   02....       LJMP    ??Subroutine31_0 & 0xFFFF
   \   00002B                REQUIRE _A_IEN0
    796          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   E8           MOV     A,R0
   \   000002   A2E7         MOV     C,0xE0 /* A   */.7
   \   000004   E4           CLR     A
   \   000005   33           RLC     A
   \   000006   F9           MOV     R1,A
   \   000007   E8           MOV     A,R0
   \   000008   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000A   22           RET
    797          
    798          /*********************************************************************
    799           * @fn      osal_msg_extract
    800           *
    801           * @brief
    802           *
    803           *    This function extracts and removes an OSAL message from the
    804           *    middle of an OSAL queue.
    805           *
    806           * @param   osal_msg_q_t *q_ptr - OSAL queue
    807           * @param   void *msg_ptr  - OSAL message to be extracted
    808           * @param   void *prev_ptr  - OSAL message before msg_ptr in queue
    809           *
    810           * @return  none
    811           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    812          void osal_msg_extract( osal_msg_q_t *q_ptr, void *msg_ptr, void *prev_ptr )
   \                     osal_msg_extract:
    813          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    814            halIntState_t intState;
    815          
    816            // Hold off interrupts
    817            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   33           RLC     A
   \   000009   FE           MOV     R6,A
   \   00000A   C2AF         CLR     0xa8.7
    818          
    819            if ( msg_ptr == *q_ptr )
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000013   EC           MOV     A,R4
   \   000014   68           XRL     A,R0
   \   000015   7002         JNZ     ??osal_msg_extract_0
   \   000017   ED           MOV     A,R5
   \   000018   69           XRL     A,R1
   \                     ??osal_msg_extract_0:
   \   000019   700C         JNZ     ??osal_msg_extract_1
    820            {
    821              // remove from first
    822              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   00001B   12....       LCALL   ?Subroutine25 & 0xFFFF
    823            }
   \                     ??CrossCallReturnLabel_34:
   \   00001E   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   8017         SJMP    ??CrossCallReturnLabel_51
    824            else
    825            {
    826              // remove from middle
    827              OSAL_MSG_NEXT( prev_ptr ) = OSAL_MSG_NEXT( msg_ptr );
   \                     ??osal_msg_extract_1:
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
    828            }
   \                     ??CrossCallReturnLabel_35:
   \   00002A   12....       LCALL   ??Subroutine33_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00002D   7409         MOV     A,#0x9
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FA           MOV     R2,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   CA           XCH     A,R2
   \   000037   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00003A   EA           MOV     A,R2
   \   00003B   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00003E   E8           MOV     A,R0
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   A3           INC     DPTR
   \   000041   E9           MOV     A,R1
   \   000042   F0           MOVX    @DPTR,A
    829            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000043   12....       LCALL   ?Subroutine23 & 0xFFFF
    830            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \                     ??CrossCallReturnLabel_31:
   \   000046   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000049   74FF         MOV     A,#-0x1
   \   00004B   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   00004E                REQUIRE _A_IEN0
    831          
    832            // Re-enable interrupts
    833            HAL_EXIT_CRITICAL_SECTION(intState);
    834          }
    835          
    836          /*********************************************************************
    837           * @fn      osal_msg_enqueue_max
    838           *
    839           * @brief
    840           *
    841           *    This function enqueues an OSAL message into an OSAL queue if
    842           *    the length of the queue is less than max.
    843           *
    844           * @param   osal_msg_q_t *q_ptr - OSAL queue
    845           * @param   void *msg_ptr  - OSAL message
    846           * @param   uint8 max - maximum length of queue
    847           *
    848           * @return  TRUE if message was enqueued, FALSE otherwise
    849           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    850          uint8 osal_msg_enqueue_max( osal_msg_q_t *q_ptr, void *msg_ptr, uint8 max )
   \                     osal_msg_enqueue_max:
    851          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   E9           MOV     A,R1
   \   00000A   FE           MOV     R6,A
    852            void *list;
    853            uint8 ret = FALSE;
   \   00000B   7A00         MOV     R2,#0x0
    854            halIntState_t intState;
    855          
    856            // Hold off interrupts
    857            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   33           RLC     A
   \   000011   FB           MOV     R3,A
   \   000012   C2AF         CLR     0xa8.7
    858          
    859            // If first message in queue
    860            if ( *q_ptr == NULL )
   \   000014   85..82       MOV     DPL,?V0
   \   000017   85..83       MOV     DPH,?V1
   \   00001A   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   00001D   700E         JNZ     ??CrossCallReturnLabel_46
    861            {
    862              *q_ptr = msg_ptr;
   \   00001F   85..82       MOV     DPL,?V0
   \   000022   85..83       MOV     DPH,?V1
   \   000025   801D         SJMP    ??CrossCallReturnLabel_57
    863              ret = TRUE;
    864            }
    865            else
    866            {
    867              // Find end of queue or max
    868              list = *q_ptr;
    869              max--;
    870              while ( (OSAL_MSG_NEXT( list ) != NULL) && (max > 0) )
   \                     ??osal_msg_enqueue_max_0:
   \   000027   EE           MOV     A,R6
   \   000028   6021         JZ      ??osal_msg_enqueue_max_1
    871              {
    872                list = OSAL_MSG_NEXT( list );
   \   00002A   12....       LCALL   ?Subroutine10 & 0xFFFF
    873                max--;
   \                     ??CrossCallReturnLabel_46:
   \   00002D   1E           DEC     R6
    874              }
   \   00002E   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F5..         MOV     ?V0,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F5..         MOV     ?V1,A
   \   000038   E5..         MOV     A,?V0
   \   00003A   45..         ORL     A,?V1
   \   00003C   70E9         JNZ     ??osal_msg_enqueue_max_0
    875          
    876              // Add message to end of queue if max not reached
    877              if ( max != 0 )
   \   00003E   EE           MOV     A,R6
   \   00003F   600A         JZ      ??osal_msg_enqueue_max_1
    878              {
    879                OSAL_MSG_NEXT( list ) = msg_ptr;
   \   000041   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000044   EC           MOV     A,R4
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   ED           MOV     A,R5
   \   000048   F0           MOVX    @DPTR,A
    880                ret = TRUE;
   \   000049   7A01         MOV     R2,#0x1
    881              }
    882            }
    883          
    884            // Re-enable interrupts
    885            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_max_1:
   \   00004B   EB           MOV     A,R3
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   92AF         MOV     0xa8.7,C
    886          
    887            return ret;
   \   000050   EA           MOV     A,R2
   \   000051   F9           MOV     R1,A
   \   000052   02....       LJMP    ?Subroutine3 & 0xFFFF
   \   000055                REQUIRE _A_IEN0
    888          }
    889          
    890          /*********************************************************************
    891           * @fn      osal_set_event
    892           *
    893           * @brief
    894           *
    895           *    This function is called to set the event flags for a task. The
    896           *    event passed in is OR'd into the task's event variable.
    897           *
    898           * @param   uint8 task_id - receiving tasks ID
    899           * @param   uint8 event_flag - what event to set
    900           *
    901           * @return  SUCCESS, INVALID_TASK
    902           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    903          uint8 osal_set_event( uint8 task_id, uint16 event_flag )
   \                     osal_set_event:
    904          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    905            if ( task_id < tasksCnt )
   \   000007   90....       MOV     DPTR,#tasksCnt
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   EE           MOV     A,R6
   \   00000D   C3           CLR     C
   \   00000E   98           SUBB    A,R0
   \   00000F   502D         JNC     ??osal_set_event_0
    906            {
    907              halIntState_t   intState;
    908              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   000011   ACA8         MOV     R4,0xa8+0x0
   \   000013   C2AF         CLR     0xa8.7
    909              tasksEvents[task_id] |= event_flag;  // Stuff the event bit(s)
   \   000015   EE           MOV     A,R6
   \   000016   29           ADD     A,R1
   \   000017   F8           MOV     R0,A
   \   000018   E4           CLR     A
   \   000019   33           RLC     A
   \   00001A   F9           MOV     R1,A
   \   00001B   90....       MOV     DPTR,#tasksEvents
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   28           ADD     A,R0
   \   000020   FD           MOV     R5,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   39           ADDC    A,R1
   \   000024   8D82         MOV     DPL,R5
   \   000026   F583         MOV     DPH,A
   \   000028   E0           MOVX    A,@DPTR
   \   000029   4A           ORL     A,R2
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   4B           ORL     A,R3
   \   00002E   F0           MOVX    @DPTR,A
    910              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   00002F   EC           MOV     A,R4
   \   000030   A2E7         MOV     C,0xE0 /* A   */.7
   \   000032   E4           CLR     A
   \   000033   33           RLC     A
   \   000034   F8           MOV     R0,A
   \   000035   EC           MOV     A,R4
   \   000036   A2E7         MOV     C,0xE0 /* A   */.7
   \   000038   92AF         MOV     0xa8.7,C
    911              return ( SUCCESS );
   \   00003A   7900         MOV     R1,#0x0
   \   00003C   8002         SJMP    ??osal_set_event_1
    912            }
    913             else
    914            {
    915              return ( INVALID_TASK );
   \                     ??osal_set_event_0:
   \   00003E   7903         MOV     R1,#0x3
    916            }
   \                     ??osal_set_event_1:
   \   000040   02....       LJMP    ??Subroutine32_0 & 0xFFFF
   \   000043                REQUIRE _A_IEN0
    917          }
    918          
    919          /*********************************************************************
    920           * @fn      osal_clear_event
    921           *
    922           * @brief
    923           *
    924           *    This function is called to clear the event flags for a task. The
    925           *    event passed in is masked out of the task's event variable.
    926           *
    927           * @param   uint8 task_id - receiving tasks ID
    928           * @param   uint8 event_flag - what event to clear
    929           *
    930           * @return  SUCCESS, INVALID_TASK
    931           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    932          uint8 osal_clear_event( uint8 task_id, uint16 event_flag )
   \                     osal_clear_event:
    933          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
    934            if ( task_id < tasksCnt )
   \   000007   90....       MOV     DPTR,#tasksCnt
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   EF           MOV     A,R7
   \   00000D   C3           CLR     C
   \   00000E   98           SUBB    A,R0
   \   00000F   5025         JNC     ??osal_clear_event_0
    935            {
    936              halIntState_t   intState;
    937              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   000011   AEA8         MOV     R6,0xa8+0x0
   \   000013   C2AF         CLR     0xa8.7
    938              tasksEvents[task_id] &= ~(event_flag);   // Clear the event bit(s)
   \   000015   EA           MOV     A,R2
   \   000016   F4           CPL     A
   \   000017   FC           MOV     R4,A
   \   000018   EB           MOV     A,R3
   \   000019   F4           CPL     A
   \   00001A   FD           MOV     R5,A
   \   00001B   EF           MOV     A,R7
   \   00001C   29           ADD     A,R1
   \   00001D   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000020   E0           MOVX    A,@DPTR
   \   000021   5C           ANL     A,R4
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   5D           ANL     A,R5
   \   000026   F0           MOVX    @DPTR,A
    939              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   000027   EE           MOV     A,R6
   \   000028   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002A   E4           CLR     A
   \   00002B   33           RLC     A
   \   00002C   F8           MOV     R0,A
   \   00002D   EE           MOV     A,R6
   \   00002E   A2E7         MOV     C,0xE0 /* A   */.7
   \   000030   92AF         MOV     0xa8.7,C
    940              return ( SUCCESS );
   \   000032   7900         MOV     R1,#0x0
   \   000034   8002         SJMP    ??osal_clear_event_1
    941            }
    942             else
    943            {
    944              return ( INVALID_TASK );
   \                     ??osal_clear_event_0:
   \   000036   7903         MOV     R1,#0x3
    945            }
   \                     ??osal_clear_event_1:
   \   000038   02....       LJMP    ??Subroutine32_0 & 0xFFFF
   \   00003B                REQUIRE _A_IEN0
    946          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   33           RLC     A
   \   000003   F9           MOV     R1,A
   \   000004   90....       MOV     DPTR,#tasksEvents
   \   000007   E0           MOVX    A,@DPTR
   \   000008   28           ADD     A,R0
   \   000009   FA           MOV     R2,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   39           ADDC    A,R1
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   F583         MOV     DPH,A
   \   000011   22           RET
    947          
    948          /*********************************************************************
    949           * @fn      osal_isr_register
    950           *
    951           * @brief
    952           *
    953           *   This function is called to register a service routine with an
    954           *   interrupt. When the interrupt occurs, this service routine is called.
    955           *
    956           * @param   uint8 interrupt_id - Interrupt number
    957           * @param   void (*isr_ptr)( uint8* ) - function pointer to ISR
    958           *
    959           * @return  SUCCESS, INVALID_INTERRUPT_ID,
    960           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    961          uint8 osal_isr_register( uint8 interrupt_id, void (*isr_ptr)( uint8* ) )
   \                     osal_isr_register:
    962          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    963            // Remove these statements when functionality is complete
    964            (void)interrupt_id;
    965            (void)isr_ptr;
    966            return ( SUCCESS );
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
    967          }
    968          
    969          /*********************************************************************
    970           * @fn      osal_int_enable
    971           *
    972           * @brief
    973           *
    974           *   This function is called to enable an interrupt. Once enabled,
    975           *   occurrence of the interrupt causes the service routine associated
    976           *   with that interrupt to be called.
    977           *
    978           *   If INTS_ALL is the interrupt_id, interrupts (in general) are enabled.
    979           *   If a single interrupt is passed in, then interrupts still have
    980           *   to be enabled with another call to INTS_ALL.
    981           *
    982           * @param   uint8 interrupt_id - Interrupt number
    983           *
    984           * @return  SUCCESS or INVALID_INTERRUPT_ID
    985           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    986          uint8 osal_int_enable( uint8 interrupt_id )
   \                     osal_int_enable:
    987          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   \   000001   F8           MOV     R0,A
    988          
    989            if ( interrupt_id == INTS_ALL )
   \   000002   74FF         MOV     A,#-0x1
   \   000004   68           XRL     A,R0
   \   000005   7006         JNZ     ??osal_int_enable_0
    990            {
    991              HAL_ENABLE_INTERRUPTS();
   \   000007   D2AF         SETB    0xa8.7
    992              return ( SUCCESS );
   \   000009   7900         MOV     R1,#0x0
   \   00000B   8002         SJMP    ??osal_int_enable_1
    993            }
    994            else
    995            {
    996              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_enable_0:
   \   00000D   7907         MOV     R1,#0x7
   \                     ??osal_int_enable_1:
   \   00000F   02....       LJMP    ?BRET
   \   000012                REQUIRE _A_IEN0
    997            }
    998          }
    999          
   1000          /*********************************************************************
   1001           * @fn      osal_int_disable
   1002           *
   1003           * @brief
   1004           *
   1005           *   This function is called to disable an interrupt. When a disabled
   1006           *   interrupt occurs, the service routine associated with that
   1007           *   interrupt is not called.
   1008           *
   1009           *   If INTS_ALL is the interrupt_id, interrupts (in general) are disabled.
   1010           *   If a single interrupt is passed in, then just that interrupt is disabled.
   1011           *
   1012           * @param   uint8 interrupt_id - Interrupt number
   1013           *
   1014           * @return  SUCCESS or INVALID_INTERRUPT_ID
   1015           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1016          uint8 osal_int_disable( uint8 interrupt_id )
   \                     osal_int_disable:
   1017          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   \   000001   F8           MOV     R0,A
   1018          
   1019            if ( interrupt_id == INTS_ALL )
   \   000002   74FF         MOV     A,#-0x1
   \   000004   68           XRL     A,R0
   \   000005   7006         JNZ     ??osal_int_disable_0
   1020            {
   1021              HAL_DISABLE_INTERRUPTS();
   \   000007   C2AF         CLR     0xa8.7
   1022              return ( SUCCESS );
   \   000009   7900         MOV     R1,#0x0
   \   00000B   8002         SJMP    ??osal_int_disable_1
   1023            }
   1024            else
   1025            {
   1026              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_disable_0:
   \   00000D   7907         MOV     R1,#0x7
   \                     ??osal_int_disable_1:
   \   00000F   02....       LJMP    ?BRET
   \   000012                REQUIRE _A_IEN0
   1027            }
   1028          }
   1029          
   1030          /*********************************************************************
   1031           * @fn      osal_init_system
   1032           *
   1033           * @brief
   1034           *
   1035           *   This function initializes the "task" system by creating the
   1036           *   tasks defined in the task table (OSAL_Tasks.h).
   1037           *
   1038           * @param   void
   1039           *
   1040           * @return  SUCCESS
   1041           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1042          uint8 osal_init_system( void )
   \                     osal_init_system:
   1043          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1044            // Initialize the Memory Allocation System
   1045            osal_mem_init();
   \   000004                ; Setup parameters for call to function osal_mem_init
   \   000004   12....       LCALL   `??osal_mem_init::?relay`; Banked call to: osal_mem_init
   1046          
   1047            // Initialize the message queue
   1048            osal_qHead = NULL;
   \   000007   90....       MOV     DPTR,#osal_qHead
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
   1049          
   1050            // Initialize the timers
   1051            osalTimerInit();
   \   00000E                ; Setup parameters for call to function osalTimerInit
   \   00000E   12....       LCALL   `??osalTimerInit::?relay`; Banked call to: osalTimerInit
   1052          
   1053            // Initialize the Power Management System
   1054            osal_pwrmgr_init();
   \   000011                ; Setup parameters for call to function osal_pwrmgr_init
   \   000011   12....       LCALL   `??osal_pwrmgr_init::?relay`; Banked call to: osal_pwrmgr_init
   1055          
   1056            // Initialize the system tasks.
   1057            osalInitTasks();
   \   000014                ; Setup parameters for call to function osalInitTasks
   \   000014   12....       LCALL   `??osalInitTasks::?relay`; Banked call to: osalInitTasks
   1058          
   1059            // Setup efficient search for the first free block of heap.
   1060            osal_mem_kick();
   \   000017                ; Setup parameters for call to function osal_mem_kick
   \   000017   12....       LCALL   `??osal_mem_kick::?relay`; Banked call to: osal_mem_kick
   1061          
   1062            return ( SUCCESS );
   \   00001A   7900         MOV     R1,#0x0
   \   00001C   02....       LJMP    ?Subroutine0 & 0xFFFF
   1063          }
   1064          
   1065          /*********************************************************************
   1066           * @fn      osal_start_system
   1067           *
   1068           * @brief
   1069           *
   1070           *   This function is the main loop function of the task system (if
   1071           *   ZBIT and UBIT are not defined). This Function doesn't return.
   1072           *
   1073           * @param   void
   1074           *
   1075           * @return  none
   1076           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1077          void osal_start_system( void )
   \                     osal_start_system:
   1078          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1079          #if !defined ( ZBIT ) && !defined ( UBIT )
   1080            for(;;)  // Forever Loop
   1081          #endif
   1082            {
   1083              osal_run_system();
   \                     ??osal_start_system_0:
   \   000004                ; Setup parameters for call to function osal_run_system
   \   000004   12....       LCALL   `??osal_run_system::?relay`; Banked call to: osal_run_system
   \   000007   80FB         SJMP    ??osal_start_system_0
   1084            }
   1085          }
   1086          
   1087          /*********************************************************************
   1088           * @fn      osal_run_system
   1089           *
   1090           * @brief
   1091           *
   1092           *   This function will make one pass through the OSAL taskEvents table
   1093           *   and call the task_event_processor() function for the first task that
   1094           *   is found with at least one event pending. If there are no pending
   1095           *   events (all tasks), this function puts the processor into Sleep.
   1096           *
   1097           * @param   void
   1098           *
   1099           * @return  none
   1100           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1101          void osal_run_system( void )
   \                     osal_run_system:
   1102          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1103            uint8 idx = 0;
   \   000005   75..00       MOV     ?V0,#0x0
   1104          
   1105          #ifndef HAL_BOARD_CC2538
   1106            osalTimeUpdate();
   \   000008                ; Setup parameters for call to function osalTimeUpdate
   \   000008   12....       LCALL   `??osalTimeUpdate::?relay`; Banked call to: osalTimeUpdate
   1107          #endif
   1108            
   1109            Hal_ProcessPoll();
   \   00000B                ; Setup parameters for call to function Hal_ProcessPoll
   \   00000B   12....       LCALL   `??Hal_ProcessPoll::?relay`; Banked call to: Hal_ProcessPoll
   1110          
   1111            do {
   1112              if (tasksEvents[idx])  // Task is highest priority that is ready.
   \                     ??osal_run_system_0:
   \   00000E   A8..         MOV     R0,?V0
   \   000010   E8           MOV     A,R0
   \   000011   28           ADD     A,R0
   \   000012   12....       LCALL   ?Subroutine11 & 0xFFFF
   1113              {
   1114                break;
   1115              }
   1116            } while (++idx < tasksCnt);
   \                     ??CrossCallReturnLabel_6:
   \   000015   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000018   700D         JNZ     ??osal_run_system_1
   \   00001A   05..         INC     ?V0
   \   00001C   90....       MOV     DPTR,#tasksCnt
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F8           MOV     R0,A
   \   000021   E5..         MOV     A,?V0
   \   000023   C3           CLR     C
   \   000024   98           SUBB    A,R0
   \   000025   40E7         JC      ??osal_run_system_0
   1117          
   1118            if (idx < tasksCnt)
   \                     ??osal_run_system_1:
   \   000027   90....       MOV     DPTR,#tasksCnt
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   E5..         MOV     A,?V0
   \   00002E   C3           CLR     C
   \   00002F   98           SUBB    A,R0
   \   000030   506A         JNC     ??osal_run_system_2
   1119            {
   1120              uint16 events;
   1121              halIntState_t intState;
   1122          
   1123              HAL_ENTER_CRITICAL_SECTION(intState);
   \   000032   ACA8         MOV     R4,0xa8+0x0
   \   000034   C2AF         CLR     0xa8.7
   1124              events = tasksEvents[idx];
   \   000036   AE..         MOV     R6,?V0
   \   000038   EE           MOV     A,R6
   \   000039   2E           ADD     A,R6
   \   00003A   FE           MOV     R6,A
   \   00003B   E4           CLR     A
   \   00003C   33           RLC     A
   \   00003D   FF           MOV     R7,A
   \   00003E   90....       MOV     DPTR,#tasksEvents
   \   000041   E0           MOVX    A,@DPTR
   \   000042   2E           ADD     A,R6
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   3F           ADDC    A,R7
   \   000047   F9           MOV     R1,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   8983         MOV     DPH,R1
   \   00004C   12....       LCALL   ??Subroutine39_0 & 0xFFFF
   1125              tasksEvents[idx] = 0;  // Clear the Events for this task.
   \                     ??CrossCallReturnLabel_82:
   \   00004F   8882         MOV     DPL,R0
   \   000051   8983         MOV     DPH,R1
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   F0           MOVX    @DPTR,A
   1126              HAL_EXIT_CRITICAL_SECTION(intState);
   \   000057   EC           MOV     A,R4
   \   000058   A2E7         MOV     C,0xE0 /* A   */.7
   \   00005A   E4           CLR     A
   \   00005B   33           RLC     A
   \   00005C   F5..         MOV     ?V1,A
   \   00005E   EC           MOV     A,R4
   \   00005F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000061   92AF         MOV     0xa8.7,C
   1127          
   1128              activeTaskID = idx;
   \   000063   E5..         MOV     A,?V0
   \   000065   90....       MOV     DPTR,#activeTaskID
   \   000068   F0           MOVX    @DPTR,A
   1129              events = (tasksArr[idx])( idx, events );
   \   000069                ; Setup parameters for indirect call
   \   000069   F9           MOV     R1,A
   \   00006A   74..         MOV     A,#tasksArr & 0xff
   \   00006C   2E           ADD     A,R6
   \   00006D   F582         MOV     DPL,A
   \   00006F   74..         MOV     A,#(tasksArr >> 8) & 0xff
   \   000071   3F           ADDC    A,R7
   \   000072   F583         MOV     DPH,A
   \   000074   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000077   12....       LCALL   ?CALL_IND
   1130              activeTaskID = TASK_NO_TASK;
   \   00007A   90....       MOV     DPTR,#activeTaskID
   \   00007D   74FF         MOV     A,#-0x1
   \   00007F   F0           MOVX    @DPTR,A
   1131          
   1132              HAL_ENTER_CRITICAL_SECTION(intState);
   \   000080   A8A8         MOV     R0,0xa8+0x0
   \   000082   C2AF         CLR     0xa8.7
   1133              tasksEvents[idx] |= events;  // Add back unprocessed events to the current task.
   \   000084   90....       MOV     DPTR,#tasksEvents
   \   000087   E0           MOVX    A,@DPTR
   \   000088   2E           ADD     A,R6
   \   000089   F9           MOV     R1,A
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   3F           ADDC    A,R7
   \   00008D   8982         MOV     DPL,R1
   \   00008F   F583         MOV     DPH,A
   \   000091   E0           MOVX    A,@DPTR
   \   000092   4A           ORL     A,R2
   \   000093   F0           MOVX    @DPTR,A
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   4B           ORL     A,R3
   \   000097   12....       LCALL   ?Subroutine17 & 0xFFFF
   1134              HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??CrossCallReturnLabel_18:
   \   00009A   92AF         MOV     0xa8.7,C
   1135            }
   1136          #if defined( POWER_SAVING )
   1137            else  // Complete pass through all task events with no activity?
   1138            {
   1139              osal_pwrmgr_powerconserve();  // Put the processor/system into sleep
   1140            }
   1141          #endif
   1142          
   1143            /* Yield in case cooperative scheduling is being used. */
   1144          #if defined (configUSE_PREEMPTION) && (configUSE_PREEMPTION == 0)
   1145            {
   1146              osal_task_yield();
   1147            }
   1148          #endif
   1149          }
   \                     ??osal_run_system_2:
   \   00009C   02....       LJMP    ?Subroutine4 & 0xFFFF
   \   00009F                REQUIRE _A_IEN0
   1150          
   1151          /*********************************************************************
   1152           * @fn      osal_buffer_uint32
   1153           *
   1154           * @brief
   1155           *
   1156           *   Buffer an uint32 value - LSB first.
   1157           *
   1158           * @param   buf - buffer
   1159           * @param   val - uint32 value
   1160           *
   1161           * @return  pointer to end of destination buffer
   1162           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1163          uint8* osal_buffer_uint32( uint8 *buf, uint32 val )
   \                     osal_buffer_uint32:
   1164          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   78..         MOV     R0,#?V4
   \   00000C   12....       LCALL   ?L_MOV_X
   1165            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   12....       LCALL   ?Subroutine21 & 0xFFFF
   1166            *buf++ = BREAK_UINT32( val, 1 );
   1167            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_25:
   \   000012   85....       MOV     ?V0,?V4
   \   000015   85....       MOV     ?V2,?V6
   \   000018   85....       MOV     ?V3,?V7
   \   00001B   7410         MOV     A,#0x10
   \   00001D   78..         MOV     R0,#?V0
   \   00001F   12....       LCALL   ?UL_SHR
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E5..         MOV     A,?V0
   \   00002A   F0           MOVX    @DPTR,A
   1168            *buf++ = BREAK_UINT32( val, 3 );
   \   00002B   7418         MOV     A,#0x18
   \   00002D   78..         MOV     R0,#?V4
   \   00002F   12....       LCALL   ?UL_SHR
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E5..         MOV     A,?V4
   \   00003B   F0           MOVX    @DPTR,A
   1169          
   1170            return buf;
   \   00003C   EA           MOV     A,R2
   \   00003D   2404         ADD     A,#0x4
   \   00003F   FA           MOV     R2,A
   \   000040   5001         JNC     ??osal_buffer_uint32_0
   \   000042   0B           INC     R3
   \                     ??osal_buffer_uint32_0:
   \   000043                REQUIRE ?Subroutine2
   \   000043                ; // Fall through to label ?Subroutine2
   1171          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   E5..         MOV     A,?V4
   \   000006   F0           MOVX    @DPTR,A
   \   000007   85....       MOV     ?V1,?V5
   \   00000A   E5..         MOV     A,?V1
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   22           RET
   1172          
   1173          /*********************************************************************
   1174           * @fn      osal_buffer_uint24
   1175           *
   1176           * @brief
   1177           *
   1178           *   Buffer an uint24 value - LSB first. Note that type uint24 is
   1179           *   typedef to uint32 in comdef.h
   1180           *
   1181           * @param   buf - buffer
   1182           * @param   val - uint24 value
   1183           *
   1184           * @return  pointer to end of destination buffer
   1185           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1186          uint8* osal_buffer_uint24( uint8 *buf, uint24 val )
   \                     osal_buffer_uint24:
   1187          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   78..         MOV     R0,#?V4
   \   00000C   12....       LCALL   ?L_MOV_X
   1188            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   12....       LCALL   ?Subroutine21 & 0xFFFF
   1189            *buf++ = BREAK_UINT32( val, 1 );
   1190            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_26:
   \   000012   7410         MOV     A,#0x10
   \   000014   78..         MOV     R0,#?V4
   \   000016   12....       LCALL   ?UL_SHR
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E5..         MOV     A,?V4
   \   000021   F0           MOVX    @DPTR,A
   1191          
   1192            return buf;
   \   000022   EA           MOV     A,R2
   \   000023   2403         ADD     A,#0x3
   \   000025   FA           MOV     R2,A
   \   000026   5001         JNC     ??osal_buffer_uint24_0
   \   000028   0B           INC     R3
   \                     ??osal_buffer_uint24_0:
   \   000029   80..         SJMP    ?Subroutine2
   1193          }
   1194          
   1195          /*********************************************************************
   1196           * @fn      osal_isbufset
   1197           *
   1198           * @brief
   1199           *
   1200           *   Is all of the array elements set to a value?
   1201           *
   1202           * @param   buf - buffer to check
   1203           * @param   val - value to check each array element for
   1204           * @param   len - length to check
   1205           *
   1206           * @return  TRUE if all "val"
   1207           *          FALSE otherwise
   1208           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1209          uint8 osal_isbufset( uint8 *buf, uint8 val, uint8 len )
   \                     osal_isbufset:
   1210          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1211            uint8 x;
   1212          
   1213            if ( buf == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   4B           ORL     A,R3
   \   000009   6018         JZ      ??osal_isbufset_0
   1214            {
   1215              return ( FALSE );
   1216            }
   1217          
   1218            for ( x = 0; x < len; x++ )
   \   00000B   7D00         MOV     R5,#0x0
   \   00000D   8001         SJMP    ??osal_isbufset_1
   \                     ??osal_isbufset_2:
   \   00000F   0D           INC     R5
   \                     ??osal_isbufset_1:
   \   000010   ED           MOV     A,R5
   \   000011   C3           CLR     C
   \   000012   9C           SUBB    A,R4
   \   000013   5012         JNC     ??osal_isbufset_3
   1219            {
   1220              // Check for non-initialized value
   1221              if ( buf[x] != val )
   \   000015   ED           MOV     A,R5
   \   000016   F8           MOV     R0,A
   \   000017   EA           MOV     A,R2
   \   000018   28           ADD     A,R0
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   3B           ADDC    A,R3
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   60EC         JZ      ??osal_isbufset_2
   1222              {
   1223                return ( FALSE );
   \                     ??osal_isbufset_0:
   \   000023   7900         MOV     R1,#0x0
   \   000025   8002         SJMP    ??osal_isbufset_4
   1224              }
   1225            }
   1226            return ( TRUE );
   \                     ??osal_isbufset_3:
   \   000027   7901         MOV     R1,#0x1
   \                     ??osal_isbufset_4:
   \   000029   02....       LJMP    ??Subroutine32_0 & 0xFFFF
   1227          }
   1228          
   1229          /*********************************************************************
   1230           * @fn      osal_self
   1231           *
   1232           * @brief
   1233           *
   1234           *   This function returns the task ID of the current (active) task.
   1235           *
   1236           * @param   void
   1237           *
   1238           * @return   active task ID or TASK_NO_TASK if no task is active
   1239           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1240          uint8 osal_self( void )
   \                     osal_self:
   1241          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1242            return ( activeTaskID );
   \   000004   90....       MOV     DPTR,#activeTaskID
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF
   1243          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for activeTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_strlen::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_strlen

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_memcpy::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_revmemcpy::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_revmemcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_memdup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memdup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_memcmp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcmp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_memset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_build_uint16::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint16

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_build_uint32::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_ltoa::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _ltoa

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_rand::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_rand

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_allocate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_allocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_deallocate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_deallocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_send::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_send

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_push_front::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_push_front

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_enqueue_push::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_receive::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_find::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_find

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_count::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_count

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_enqueue::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_dequeue::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_dequeue

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_push::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_extract::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_extract

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_msg_enqueue_max::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue_max

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_set_event::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_set_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_clear_event::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_clear_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_isr_register::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_isr_register

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_int_enable::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_int_disable::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_disable

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_init_system::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_init_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_start_system::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_start_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_run_system::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_run_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_buffer_uint32::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_buffer_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_buffer_uint24::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_buffer_uint24

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_isbufset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_isbufset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??osal_self::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_self

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_1`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_2`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "0">`:
   \   000000   3000         DB "0"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2710:
   \   000000   10270000     DD 10000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_5f5e100:
   \   000000   00E1F505     DD 100000000
   1244          
   1245          /*********************************************************************
   1246           */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     55   _ltoa
        0     53   -> _itoa
        0     53   -> strcat
        0     53   -> strcpy
        0     53   -> strlen
      1     20   osal_buffer_uint24
      1     20   osal_buffer_uint32
      2      0   osal_build_uint16
      0     16   osal_build_uint32
      0     21   osal_clear_event
      2      0   osal_init_system
        2      0   -> osalInitTasks
        2      0   -> osalTimerInit
        2      0   -> osal_mem_init
        2      0   -> osal_mem_kick
        2      0   -> osal_pwrmgr_init
      0      0   osal_int_disable
      0      0   osal_int_enable
      0      9   osal_isbufset
      0      0   osal_isr_register
      0     21   osal_memcmp
      1     28   osal_memcpy
      0     19   osal_memdup
        0     16   -> osal_mem_alloc
        0     19   -> osal_memcpy
      0     12   osal_memset
        0     12   -> memset
      0     10   osal_msg_allocate
        0     10   -> osal_mem_alloc
      0      9   osal_msg_count
      2      9   osal_msg_deallocate
        2      0   -> osal_mem_free
      0     10   osal_msg_dequeue
      0     18   osal_msg_enqueue
      0     10   osal_msg_enqueue_max
      1     18   osal_msg_enqueue_push
        0      9   -> osal_msg_deallocate
        0      9   -> osal_msg_enqueue
        0      9   -> osal_msg_push
        0      9   -> osal_set_event
      0     23   osal_msg_extract
      2      0   osal_msg_find
      0     18   osal_msg_push
      0      9   osal_msg_push_front
        0      9   -> osal_msg_enqueue_push
      0     14   osal_msg_receive
        0     12   -> osal_clear_event
        0     14   -> osal_msg_extract
        0     12   -> osal_set_event
      0      9   osal_msg_send
        0      9   -> osal_msg_enqueue_push
      2      0   osal_rand
        2      0   -> Onboard_rand
      1     12   osal_revmemcpy
      0     12   osal_run_system
        0     12   -> Hal_ProcessPoll
        0     12   -> osalTimeUpdate
      2      0   osal_self
      0     21   osal_set_event
      2      0   osal_start_system
        2      0   -> osal_run_system
      2      0   osal_strlen
        2      0   -> strlen


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?<Constant "">
      10  ?<Constant "">_1
      10  ?<Constant "">_2
       2  ?<Constant "0">
       1  ?<Initializer for activeTaskID>
       2  ??Subroutine30_0
       2  ??Subroutine31_0
       5  ??Subroutine32_0
       4  ??Subroutine33_0
       6  ??Subroutine34_0
       3  ??Subroutine35_0
       5  ??Subroutine36_0
       5  ??Subroutine37_0
       8  ??Subroutine38_0
       6  ??Subroutine39_0
       7  ?Subroutine0
       2  ?Subroutine1
       5  ?Subroutine10
      18  ?Subroutine11
       7  ?Subroutine12
       7  ?Subroutine13
       6  ?Subroutine14
       9  ?Subroutine15
       6  ?Subroutine16
      11  ?Subroutine17
      15  ?Subroutine18
       4  ?Subroutine19
       5  ?Subroutine2
      11  ?Subroutine20
      15  ?Subroutine21
      21  ?Subroutine22
      14  ?Subroutine23
       3  ?Subroutine24
       6  ?Subroutine25
      11  ?Subroutine26
      11  ?Subroutine27
      11  ?Subroutine28
       1  ?Subroutine29
       5  ?Subroutine3
       5  ?Subroutine4
       7  ?Subroutine5
       5  ?Subroutine6
       6  ?Subroutine7
      10  ?Subroutine8
       9  ?Subroutine9
       1  _A_IEN0
       4  __Constant_2710
       4  __Constant_5f5e100
     625  _ltoa
       6  _ltoa::?relay
       1  activeTaskID
      43  osal_buffer_uint24
       6  osal_buffer_uint24::?relay
      67  osal_buffer_uint32
       6  osal_buffer_uint32::?relay
      25  osal_build_uint16
       6  osal_build_uint16::?relay
     184  osal_build_uint32
       6  osal_build_uint32::?relay
      59  osal_clear_event
       6  osal_clear_event::?relay
      31  osal_init_system
       6  osal_init_system::?relay
      18  osal_int_disable
       6  osal_int_disable::?relay
      18  osal_int_enable
       6  osal_int_enable::?relay
      44  osal_isbufset
       6  osal_isbufset::?relay
       5  osal_isr_register
       6  osal_isr_register::?relay
     130  osal_memcmp
       6  osal_memcmp::?relay
      40  osal_memcpy
       6  osal_memcpy::?relay
      55  osal_memdup
       6  osal_memdup::?relay
      31  osal_memset
       6  osal_memset::?relay
      81  osal_msg_allocate
       6  osal_msg_allocate::?relay
      58  osal_msg_count
       6  osal_msg_count::?relay
      34  osal_msg_deallocate
       6  osal_msg_deallocate::?relay
      85  osal_msg_dequeue
       6  osal_msg_dequeue::?relay
      52  osal_msg_enqueue
       6  osal_msg_enqueue::?relay
      85  osal_msg_enqueue_max
       6  osal_msg_enqueue_max::?relay
      98  osal_msg_enqueue_push
       6  osal_msg_enqueue_push::?relay
      78  osal_msg_extract
       6  osal_msg_extract::?relay
      54  osal_msg_find
       6  osal_msg_find::?relay
      43  osal_msg_push
       6  osal_msg_push::?relay
       9  osal_msg_push_front
       6  osal_msg_push_front::?relay
     122  osal_msg_receive
       6  osal_msg_receive::?relay
       7  osal_msg_send
       6  osal_msg_send::?relay
       2  osal_qHead
       9  osal_rand
       6  osal_rand::?relay
      57  osal_revmemcpy
       6  osal_revmemcpy::?relay
     159  osal_run_system
       6  osal_run_system::?relay
      12  osal_self
       6  osal_self::?relay
      67  osal_set_event
       6  osal_set_event::?relay
       9  osal_start_system
       6  osal_start_system::?relay
      10  osal_strlen
       6  osal_strlen::?relay

 
 2 803 bytes in segment BANKED_CODE
   210 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    40 bytes in segment XDATA_ROM_C
     2 bytes in segment XDATA_Z
 
 3 014 bytes of CODE  memory
    32 bytes of CONST memory (+ 8 bytes shared)
     0 bytes of DATA  memory (+ 1 byte  shared)
     3 bytes of XDATA memory

Errors: none
Warnings: none
